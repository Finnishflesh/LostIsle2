import "std.zh"
import "ghost.zh"
import "ffcscript.zh"
import "drawlayerfix.zh"

ffc script CircularMotion
//D0  radius in pixels.
//D1  speed of rotation in degrees.
//D2  starting position in degrees. If negative it will be random.
//D3  radius2, this is used for the Y Axis, if set it will turn into a oval.
//D4  angle2, this will cause the oval to be rotated at it's center like in the picture above.
{
    void run(int radius, int speed, int angle, int radius2, int angle2)
    {
        if(radius2 == 0) radius2 = radius; //Circle
        if(angle < 0) angle = Rand(360); //Random Start
        int cx = this->X;
        int cy = this->Y;
        while(true)
        {
            angle += speed;
            if(angle < -360)angle+=360; //Wrap if below -360.
            else if(angle > 360)angle-=360; //Wrap if above 360.
            if(angle2==0)
            {
                this->X = cx + radius*Cos(angle);
                this->Y = cy + radius2*Sin(angle);
            }
            else //Rotate at center.
            {
                this->X = cx + radius*Cos(angle)*Cos(angle2) - radius2*Sin(angle)*Sin(angle2);
                this->Y = cy + radius2*Sin(angle)*Cos(angle2) + radius*Cos(angle)*Sin(angle2);
            }
            Waitframe();
        }
    }
}

ffc script CollectibleCheck
{
	void run(int counter, int num)
	{
		if ( Game->Counter[counter] >= num )
			Screen->TriggerSecrets();
	}
}

item script PickupMessage
{
	void run(int m)
	{
		Screen->Message(m);
	}
}

item script HeartPieceMessageOld
//D0 = First message
//D1-3 = Second-fourth messages; default to strings after D0
{
	void run (int m1, int m2, int m3, int m4)
	{
		//Set m2-4 to follow m1 if not set explicitly
		if ( m2 == 0 ) m2 = m1+1;
		if ( m3 == 0 ) m3 = m1+2;
		if ( m4 == 0 ) m4 = m1+3;
		
		//Play the appropriate message
		if ( Game->Generic[GEN_HEARTPIECES] == 0 )
			Screen->Message(m1);
		if ( Game->Generic[GEN_HEARTPIECES] == 1 )
			Screen->Message(m2);
		if ( Game->Generic[GEN_HEARTPIECES] == 2 )
			Screen->Message(m3);
		if ( Game->Generic[GEN_HEARTPIECES] == 3 )
			Screen->Message(m4);
	}
}

ffc script ButtonDisabler{
    void run(){
        while(true){
            Link->InputStart = false; Link->PressStart = false;
            Link->InputMap = false; Link->PressMap = false;
            NoAction();
            Waitframe();
        }
    }
}

ffc script EnemyMusic
{
	void run(int bmidi, int nmidi)
	{
		while(true)
		{
			if (Screen->NumNPCs() != 0)
			{
				Game->PlayMIDI(bmidi);
			}
			else
			{
				Game->PlayMIDI(nmidi);
			}
			Waitframe();
		}
	}
}

//Constants
//GBstylecliffs constants
const int CT_CLIFF = 142; //This is the combo type used for the cliffs. Look in std_constants.zh for reference. It's Script 1 (142) by default.
const int CLIFF_PAUSE = 15; //This is the number of frames (60ths of a second) Link must walk into the cliff before jumping


//npc constants
const int ObjectRotation_BlankCombo = 1; //combo ID of a blank combo that uses the top left combo of a 4x4 block of blank tiles as it's tile

const int RESET_NPC_LAYER_ON_ENTRY = 1; //This fix will replace all CMB_NPC_SOLID tiles with CMB_NPC_HIDDEN 
									//when entering the screen. This should prevent problems with shared
									//layers. If you don't want this fix, set it to 0.
										
const int NPCSCRIPT_ITEMCHECK_ONLY_UPDATES_ON_SCREEN_ENTRY = 1; //Set to 1 if you want itemcheck NPCs to only disappear 
													//after you leave the screen.
										
const int NPCSCRIPT_WAITS_UNTIL_SCRIPTS_FINISH = 1; //This will make the script wait until a called script
											//finishes before resuming, fixing issues where you talk
											//to the NPC a second time while you should be frozen

const int LAYER_NPC = 2; //The layer NPCs use for solid combos
const int CMB_NPC_HIDDEN = 90; //Non-solid combo used for hidden NPCs
const int CMB_NPC_SOLID = 91; //Solid combo placed under visible NPCs

const int LAYER_NPC_CANTALK = 4; //The layer used for the speech bubble
const int CMB_NPC_CANTALK = 89; //The combo used for the speech bubble
const int CS_NPC_CANTALK = 7; //The CSet used for the speech bubble

const int NPCBT_NONE = 0; //Regular NPCs
const int NPCBT_FACELINK = 1; //NPCs that turn to face Link
const int NPCBT_GUARDH = 2; //NPCs that move along a horizontal path
const int NPCBT_GUARDV = 3; //NPCs that move along a vertical path

const int D_TRADE = 0; //Screen->D value used for the trade sequence state


//Constants for the Newbie Boss Moosh script
//Three colors used for the lasers
const int C_EZB_LASER1 = 0x77;
const int C_EZB_LASER2 = 0x76;
const int C_EZB_LASER3 = 0x7C;

//Three colors used for shockwaves
const int C_EZB_SHOCKWAVE1 = 0x77;
const int C_EZB_SHOCKWAVE2 = 0x76;
const int C_EZB_SHOCKWAVE3 = 0x7C;

const int SFX_EZB_TELEPORT = 32; //Sound when a boss teleports
const int SFX_EZB_LASER = 37; //Sound when a laser is fired
const int SFX_EZB_SUMMON = 56; //Sound for summoning enemies
const int SFX_EZB_DASH = 1; //Sound when dashing
const int SFX_EZB_BACKSTEP = 1; //Sound when backstepping
const int SFX_EZB_SHOCKWAVE = 2; //Sound of the boss's shockwaves
const int SFX_EZB_SHAKE = 3; //Sound of the ground shaking after a big jump
const int SFX_EZB_BARRIERSHIFT = 56; //Sound of the enemy changing forms

const int EZB_SUMMON_CAP = 8; //Max number of enemies summoned by each instance of the script
const int EZB_TOTAL_SUMMON_CAP = 40; //Max number of enemies onscreen at a time

const int EZB_DONT_REPEAT_LAST_ATTACK = 1; //If 1, the enemy will try not to repeat attacks
const int EZB_DO_WINDUP_SHAKE = 2; //0 - no shake, 1 - shake on strong attack, 2 - shake on medium attack
const int EZB_TELEPORT_TYPE = 1; //0 - Flicker, 1 - Sprite stretch, 2 - Combo offset
const int EZB_ENABLE_SPEEDTRAILS = 1; //If 1, faster movement attacks will have speed trails behind the enemy
const int EZB_ALWAYS_FAKE_Z = 0; //If 1, the Fake Z axis flag will always be set

const int EZB_WINDUP_ATTACK = 16; //Delay before a weak attack
const int EZB_WINDUP_ATTACK_MED = 32; //Delay before a medium attack
const int EZB_WINDUP_ATTACK_STRONG = 48; //Delay before a stronger attack (the boss shakes), 48 is ideal, 64 too long

const int EZB_FLYING_ZPOS = 8; //Z position for flying bosses

const int LAYER_EZB_LASER = 3; //Layer lasers are drawn to

const int SPR_EZB_DEATHEXPLOSION = 0; //Sprite to use for death explosions (0 for ZC default)
const int WIDTH_EZB_DEATHEXPLOSION = 2; //Tile width for death explosions
const int HEIGHT_EZB_DEATHEXPLOSION = 2; //Tile height for death explosions
const int EZB_DEATH_FLASH = 1; //Set to 1 to make the enemy flash during death animations
const int LW_EZB_DEATHEXPLOSION = 40; //LWeapon type used for death explosions. Script 10 by default

const int EZBF_4WAY         = 00000000001b; //1
const int EZBF_8WAY         = 00000000010b; //2
const int EZBF_FLYING       = 00000000100b; //4
const int EZBF_AQUATIC      = 00000001000b; //8
const int EZBF_NOFALL       = 00000010000b; //16
const int EZBF_EXPLODEEATH  = 00000100000b; //32
const int EZBF_FACELINK     = 00001000000b; //64
const int EZBF_UNBLOCKABLE  = 00010000000b; //128
const int EZBF_KNOCKBACK    = 00100000000b; //256
const int EZBF_NOCOLL       = 01000000000b; //512
const int EZBF_NOSTUN       = 10000000000b; //1024


//Constants for the Newbie Item Moosh script
const int LW_MOOSHITEM_MELEE = 32; //Weapon type ID for melee weapons (Script 2 for LI2)
const int TIL_INVISIBLE = 65260; //Invisible tile

const int SFX_MOOSHITEM_MELEE = 30; //Sound of a MooshItem melee swing
const int SFX_MOOSHITEM_BLOCK = 6; //Sound of a MooshItem blocking a weapon
const int SFX_MOOSHITEM_CHARGE = 35; //Sound of a MooshItem charging up
const int SFX_MOOSHITEM_WALLBOUNCE = 6; //Sound of a MooshItem projectile bouncing off a wall
const int SFX_MOOSHITEM_HP_COST = 19; //Sound that plays when a MooshItem takes Link's HP

const int MOOSHITEM_MP_DRAIN_FREQ = 10; //How many frames it takes for MP draining items to take a charge
const float MOOSHITEM_MP_DRAIN_RATIO = 0.5; //How much subsequent ticks of MP costs drain relative to the initial one

//Moosh Item Flag Constants (Don't change these)
const int MIF_4WAY         = 0000000001b; //1 - Sprites have four directions
const int MIF_8WAY         = 0000000010b; //2 - Sprites have eight directions
const int MIF_360WAY       = 0000000100b; //4 - Sprite rotates 360 degrees and faces left by default
const int MIF_2X2          = 0000001000b; //8 - Sprite is 2x2
const int MIF_PIERCE       = 0000010000b; //16 - Weapon pierces enemies
const int MIF_ANIMSTAB     = 0000100000b; //32 - Has a stab animation (Sprite+1)
const int MIF_ANIMSLASH    = 0001000000b; //64 - Has a slash animation (Sprite+1)
const int MIF_8WAYAIM      = 0010000000b; //128 - Can be aimed in 8 directions
const int MIF_EXPLODEDEATH = 0100000000b; //256 - Explodes when the weapon dies
const int MIF_DRAINMP      = 1000000000b; //512 - Drains MP over time (for circle shield/breath)


//Advanced Floor Switches
const int SFX_SWITCH_PRESS = 51; //SFX when a switch is pressed
const int SFX_SWITCH_RELEASE = 51; //SFX when a switch is released
const int SFX_SWITCH_ERROR = 40; //SFX when the wrong switch is pressed


//Bouncer Constants
const int LTTP_BUMPER_FORCE = 3; //How fast Link gets pushed back when he hits a bumper
const int LTTP_BUMPER_ANIM_SPEED = 4; //How fast the bumpers animate in frames
const int SFX_LTTP_BUMPER = 40; //The sound that plays when Link hits a bumper

const int MAX_PUSH = 4; //Max speed the script can move Link in one frame


//Constants for the Pit Script
int MooshPit[16];
const int _MP_LASTX = 0;
const int _MP_LASTY = 1;
const int _MP_LASTDMAP = 2;
const int _MP_LASTSCREEN = 3;
const int _MP_ENTRYX = 4;
const int _MP_ENTRYY = 5;
const int _MP_ENTRYDMAP = 6;
const int _MP_ENTRYSCREEN = 7;
const int _MP_FALLX = 8;
const int _MP_FALLY = 9;
const int _MP_FALLTIMER = 10;
const int _MP_FALLSTATE = 11;
const int _MP_DAMAGETYPE = 12;
const int _MP_SLIDETIMER = 13;

const int MOOSHPIT_NO_GRID_SNAP = 0; //Set to 1 to prevent Link's falling sprite from snapping to the combo grid.
const int MOOSHPIT_ENABLE_SLIDEYPITS = 0; //Set to 1 if Link should slide into pits he's partially on
const int MOOSHPIT_NO_MOVE_WHILE_FALLING = 0; //Set to 1 if you don't want Link able to move while falling
const int MOOSHPIT_NO_REENTER_STAIRS = 1; //Set to 1 to prevent Link reentering stairs when respawning from a pit. This uses an FFC slot to run the script
const int MOOSHPIT_STUN_ENEMIES_WHILE_FALLING = 0; //Set to 1 to stun stunnable enemies while falling in a pit

const int CT_HOLELAVA = 128; //Combo type for pits (No Ground Enemies by default)
const int CF_LAVA = 99; //Combo flag marking pits as lava (Script 2 for LI2)

const int SPR_FALLHOLE = 88; //Sprite for Link falling in a hole
const int SPR_FALLLAVA = 89; //Sprite for Link falling in lava

const int SFX_FALLHOLE = 38; //Sound for falling in a hole
const int SFX_FALLLAVA = 13; //Sound for falling in lava

const int DAMAGE_FALLHOLE = 8; //How much damage pits deal (1/2 heart default)
const int DAMAGE_FALLLAVA = 16; //How much damage lava deals (1 heart default)

const int FFC_MOOSHPIT_AUTOWARPA = 32; //FFC that turns into an auto side warp combo when you fall in a pit
const int CMB_MOOSHPIT_AUTOWARPA = 2; //Combo number of an invisible Auto Side Warp A combo
const int SF_MISC_MOOSHPITWARP = 2; //Number of the screen flag under the Misc. section that makes pits warp (Script 1 by default)
								    //All pit warps use Side Warp A

const int MOOSHPIT_MIN_FALL_TIME = 60; //Minimum time for the pit's fall animation, to prevent repeated falling in pits
const int MOOSHPIT_EXTRA_FALL_TIME = 0; //Extra frames at the end of the falling animation before Link respawns

//Width and height of Link's hitbox for colliding with pits
const int MOOSHPIT_LINKHITBOXWIDTH = 2;
const int MOOSHPIT_LINKHITBOXHEIGHT = 2;

//Width and height of Link's hitbox for colliding with pits/lava in sideview
const int MOOSHPIT_SIDEVIEW_LINKHITBOXWIDTH = 2;
const int MOOSHPIT_SIDEVIEW_LINKHITBOXHEIGHT = 2;

const int MOOSHPIT_SLIDEYPIT_FREQ = 3; //Link will be pushed into slideypits every 1/n frames
const int MOOSHPIT_SLIDEYPIT_MAXTIME = 20; //Link will be pushed into slideypits more intensely after n frames
const int MOOSHPIT_SLIDEYPIT_ACCELFREQ = 8; //How often Link accelerates when falling in the pit


//Constant for Hamiltonian Path
const int SFX_HAMILTINIAN_PATH = 6; //SFX that plays when you step on a hamiltonian path tile


//Constants for Crystal Switches
const int CRYSTALSWITCH_CAN_WALK_ON_TOP = 1; //If 1, Link can walk on top of raised crystal switches when they raise while under him
const int CRYSTALSWITCH_RESET_ON_F6 = 1; //If 1, switch states will reset to their defaults when F6 is pressed. Else they'll only be set when the save file is first loaded.
const int CRYSTALSWITCH_USE_BLANK_TRIGGER = 0; //If 1, the switch uses color neutral tiles when there's more than two possible color states
const int CRYSTALSWITCH_USE_FFC_GRAPHICS = 1; //If 1, the switch graphics are set to the FFC instead of the combo beneath it
const int CRYSTALSWITCH_RAISELINK = 5; //If >1 Link will be pushed up that many pixels with the block

const int CRYSTALSWITCH_NUM_COLORS = 3; //How many colors of switches are enabled
const int CRYSTALSWITCH_RISINGCOMBOS = 4; //How many combos are used in the switch rising animation
const int CRYSTALSWITCH_RISINGASPEED = 4; //A.Speed for the rising animation

const int CMB_CRYSTALSWITCH_BLOCKS = 524; //SET TO: The first of the combos for your first set of raising/lowering blocks
const int CMB_CRYSTALSWITCH_TRIGGERS = 548; //SET TO: The first of the combos for crystal switch triggers
const int CMB_CRYSTALSWITCH_STATICBLOCKS = 1112; //SET TO: The first of the combos for static (gray) blocks that you can walk over from 

const int CRYSTALSWITCH_OFFSET = 0; //How spaced apart switch combos are in the combo table. If 0, this is calculated automatically.

const int SFX_CRYSTALSWITCH_TRIGGER = 6; //Sound when the Crystal Switch is hit


//Beamos
const int LAYER_BEAMOS1 = 2; //Beamos use this layer to draw the bottom half
const int LAYER_BEAMOS2 = 3; //Beamos use this layer to draw the top half and eye
const int BEAMOS_IMPRECISION = 6; //How close the beamos must be aiming at Link to shoot
const int BEAMOS_FLASHFRAMES = 10; //How many frames the beamos flashes for before firing
const int BEAMOS_LASER_SPEED = 6; //How fast the laser shoots out
const int BEAMOS_LASER_LENGTH = 80; //How long the laser is
const int BEAMOS_LASER_MINDIST = 16; //How far the beamos can see/shoot through solid objects
const int COLOR_BEAMOS_LASER1 = 0x84; //The color of the inner laser
const int COLOR_BEAMOS_LASER2 = 0x85; //The color of the outer laser
const int CMB_BEAMOS_LASER_ENDPOINT = 1010; //The combo used for the ends of the laser
const int CS_BEAMOS_LASER_ENDPOINT = 8; //The cset used for the ends of the laser
const int SFX_BEAMOS_SIGHT = 40; //The sound that plays when the beamos sees Link
const int SFX_BEAMOS_LASER = 2; //The sound that plays when the beamos fires its laser


//Constants used by bombchu script.
const int LW_BOMBCHU = 31; //The weapon type ID of the bombchu, must be unique and between 31 and 40.
const int CF_BOMBCHU = 98; //Combo solidity on combos locations with this flag will be treated opposite by the bombchu.

item script Bombchu{
	//d0 is the ffc script slot that has the script
	//d1 is the explosion type. 0-2: bomb blast, super bomb blast, and 8 fires respectfully.
	//d2 is the movement type. 0-2: no direction changing, 4 way, and 8 way respectfully.
	//d3 is the step speed. 100 is one pixel.
	//d4 is the sprite. Sprite to use for the bombchu. Sprites are organized UP DOWN LEFT RIGHT.
	//d5 is the sfx to use if the 8 fire blast type is used.
	//Power is the damage done by the bombchu's explosion
	//The Counter reference in the pickup tab is what counter it will use.
	void run(int ffcScriptNum, int blastType, int moveType, int step, int sprite, int sfx){
		if(!Link->PressA && !Link->PressB) Quit();
		if(CountFFCsRunning(ffcScriptNum) == 0 && Game->Counter[this->Counter] > 0){
			Game->Counter[this->Counter]--;
			Game->PlaySound(SFX_PLACE);
			int args[8] = {blastType, moveType, step, sprite, sfx, this->Power};
			RunFFCScript(ffcScriptNum, args);
		}
	}
}

ffc script Bombchu_FFC{
	void run(int blastType, int moveType, int step, int sprite, int sfx, int damage){
		//Create the bombchu infront of link.
		lweapon bombchu = NextToLink(LW_BOMBCHU, 0);
		bombchu->CollDetection = false;
		bombchu->Dir = Link->Dir;
		bombchu->Step = step;
		bombchu->HitZHeight = 2;
		//Loop until it becomes invalid.
		while(bombchu->isValid()){
			//Update direction based off input, but only if moveType is between 1 and 2.
			if(moveType == VBound(moveType, 2, 1)){
				int dir = -1;
				if(Link->InputUp && !Link->InputDown) dir = DIR_UP;
				else if(Link->InputDown && !Link->InputUp) dir = DIR_DOWN;
				if(Link->InputLeft && !Link->InputRight){
					if(moveType == 2){
						if(dir == DIR_UP) dir = DIR_LEFTUP;
						if(dir == DIR_DOWN) dir = DIR_LEFTDOWN;
					}
					if(dir == -1) dir = DIR_LEFT;
				}
				else if(Link->InputRight && !Link->InputLeft){
					if(moveType == 2){
						if(dir == DIR_UP) dir = DIR_RIGHTUP;
						if(dir == DIR_DOWN) dir = DIR_RIGHTDOWN;
					}
					if(dir == -1) dir = DIR_RIGHT;
				}
				if(dir != -1) bombchu->Dir = dir;
			}
			//Update the sprite based off direction.
			bombchu->UseSprite(sprite);
			bombchu->OriginalTile += bombchu->NumFrames*bombchu->Dir;
			//Declare variables to be used to detect collisions.
			bool contact;
			int dir = bombchu->Dir;
			//If the bombchu is about to go off screen expode.
			if(dir == 0 || dir == 4 || dir == 5) contact = (bombchu->Y - step/100 <= 0);
			else if(dir == 1 || dir == 6 || dir == 7) contact = (bombchu->Y + step/100 >= 152);
			else if(dir == 2 || dir == 4 || dir == 6) contact = (bombchu->X - step/100 <= 0);
			else if(dir == 3 || dir == 5 || dir == 7) contact = (bombchu->X + step/100 >= 240);
			//If the bombchu collided with a npc expode.
			for(int i = Screen->NumNPCs(); i > 0 && !contact; i--){
				npc n = Screen->LoadNPC(i);
				if(!n->CollDetection) continue;
				if(n->ID == NPC_ITEMFAIRY) continue;
				if(n->Type == NPCT_PEAHAT && n->Step != 0 && n->Z == 0) continue;
				if(n->Defense[NPCD_SCRIPT] == NPCDT_IGNORE) continue;
				if(Collision(n, bombchu)) contact = true;
			}
			//If the bombchu is about to hit something solid according to bombchu solidity explode.
			if(!contact){
			   int x = bombchu->X + AtFrontX(bombchu->Dir);
			   int y = bombchu->Y + AtFrontY(bombchu->Dir);
			   if(!contact){
				   if(ComboFI(x, y, CF_BOMBCHU)) contact = !Screen->isSolid(x, y);
				   else contact = Screen->isSolid(x, y);
			   }
			   if(IsWater(ComboAt(x,y)) || IsPit(ComboAt(x,y))) contact = true;
			}
			if(Link->Action == LA_GOTHURTLAND) contact = true;
			//If contact was set to true explode.
			if(contact){
				if(blastType == 0){
					lweapon blast = CreateLWeaponAt(LW_BOMBBLAST, bombchu->X, bombchu->Y);
					blast->Damage = damage;
				}
				else if(blastType == 1){
					lweapon blast = CreateLWeaponAt(LW_SBOMBBLAST, bombchu->X, bombchu->Y);
					blast->Damage = damage;
				}
				else if(blastType == 2){
					for(int i; i < 8; i++){
						lweapon fire = CreateLWeaponAt(LW_FIRE, bombchu->X, bombchu->Y);
						fire->Dir = i;
						fire->Step = 100;
						fire->Angular = true;
						fire->Angle = DegtoRad(i*45);
						fire->Damage = damage;
					}
				}
				bombchu->DeadState = 0;
				Game->PlaySound(sfx);
			}
			WaitNoAction();
		}
	}
}

ffc script ObjectRotation{
	void run(int DrawLayer, int RotationSpeed){
		int OriginalCombo = this->Data;
		this->Data = ObjectRotation_BlankCombo;
		int Opacity = OP_OPAQUE;
		if ( this->Flags[FFCF_TRANS] )
			Opacity = OP_TRANS;
		int Rotation;
		while(true){
			Screen->DrawTile(DrawLayer, this->X, this->Y, Game->ComboTile(OriginalCombo), this->TileWidth, this->TileHeight, this->CSet, -1, -1, this->X, this->Y, Rotation, 0, true, Opacity);
			Rotation += RotationSpeed;
			if(Rotation < -360)Rotation+=360; //Wrap if below -360. ???? i dont know
			else if(Rotation > 360)Rotation-=360; //Wrap if above 360. ???? i dont know
			Waitframe();
		}
	}
}

ffc script NPCScript{
	void run(int String, int ItemCheck, int Type, int Arg1, int Arg2, int NoSolid, int Script, int ScriptArg){
		//Stores the NPC's combo, hides it
		int Combo = this->Data;
		this->Data = CMB_NPC_HIDDEN;
		//Waits until the NPC should appear and shows it
		if(ItemCheck<0){
			while(!Link->Item[Abs(ItemCheck)]){
				Waitframe();
			}
			this->Data = Combo;
			if(Type==NPCBT_FACELINK){
				this->Data = Combo + Arg1;
			}
		}
		else if(ItemCheck>0){
			if(!Link->Item[Abs(ItemCheck)]){
				this->Data = Combo;
				if(Type==NPCBT_FACELINK){
					this->Data = Combo + Arg1;
				}
			}
		}
		else if(ItemCheck==0){
			this->Data = Combo;
			if(Type==NPCBT_FACELINK){
				this->Data = Combo + Arg1;
			}
		}
		//Saves the width and height of the FFC for collision checks
		int Width = 16;
		int Height = 16;
		if(this->EffectWidth!=16)
			Width = this->EffectWidth;
		else if(this->TileWidth>1)
			Width = this->TileWidth*16;
		if(this->EffectHeight!=16)
			Height = this->EffectHeight;
		else if(this->TileHeight>1)
			Height = this->TileHeight*16;
		//Wait until the screen is done scrolling to avoid a weird ZC crashing bug
		Waitframe();
		while(Link->Action==LA_SCROLLING){
			Waitframe();
		}
		//Shared Layer Fix
		if(RESET_NPC_LAYER_ON_ENTRY==1){
			if(Screen->LoadFFC(FindFFCRunning(this->Script))==this){
				for(int i=0; i<176; i++){
					if(GetLayerComboD(LAYER_NPC, i)==CMB_NPC_SOLID){
						SetLayerComboD(LAYER_NPC, i, CMB_NPC_HIDDEN);
					}
				}
			}
		}
		//Sets the space below the NPC or the space a guard NPC occupies to be solid
		if(LAYER_NPC>-1&&NoSolid==0){
			if(Type==NPCBT_GUARDH){
				for(int x=Arg1; x<=Arg2+this->TileWidth-1; x++){
					for(int y=Floor(this->Y/16); y<=Floor(this->Y/16)+this->TileHeight-1; y++){
						SetLayerComboD(LAYER_NPC, y*16+x, CMB_NPC_SOLID);
					}
				}
			}
			else if(Type==NPCBT_GUARDV){
				for(int x=Floor(this->X/16); x<=Floor(this->X/16)+this->TileWidth-1; x++){
					for(int y=Arg1; y<=Arg2+this->TileHeight-1; y++){
						SetLayerComboD(LAYER_NPC, y*16+x, CMB_NPC_SOLID);
					}
				}
			}
			else{
				for(int x=Floor(this->X/16); x<=Floor(this->X/16)+this->TileWidth-1; x++){
					for(int y=Floor(this->Y/16); y<=Floor(this->Y/16)+this->TileHeight-1; y++){
						SetLayerComboD(LAYER_NPC, y*16+x, CMB_NPC_SOLID);
					}
				}
			}
		}
		bool canItemCheck = true;
		while(true){
			//Prevent checking items past the first frame if the rule is checked
			if(!NPCSCRIPT_ITEMCHECK_ONLY_UPDATES_ON_SCREEN_ENTRY)
				canItemCheck = true;
			
			//Removes NPCs if Link has the required item
			if(ItemCheck>0&&canItemCheck){
				if(Link->Item[ItemCheck]){
					this->Data = CMB_NPC_HIDDEN;
					if(LAYER_NPC>-1&&NoSolid==0){
						if(Type==NPCBT_GUARDH){
							for(int x=Arg1; x<=Arg2+this->TileWidth-1; x++){
								for(int y=Floor(this->Y/16); y<=Floor(this->Y/16)+this->TileHeight-1; y++){
									SetLayerComboD(LAYER_NPC, y*16+x, CMB_NPC_HIDDEN);
								}
							}
						}
						else if(Type==NPCBT_GUARDV){
							for(int x=Floor(this->X/16); x<=Floor(this->X/16)+this->TileWidth-1; x++){
								for(int y=Arg1; y<=Arg2+this->TileHeight-1; y++){
									SetLayerComboD(LAYER_NPC, y*16+x, CMB_NPC_HIDDEN);
								}
							}
						}
						else{
							for(int x=Floor(this->X/16); x<=Floor(this->X/16)+this->TileWidth-1; x++){
								for(int y=Floor(this->Y/16); y<=Floor(this->Y/16)+this->TileHeight-1; y++){
									SetLayerComboD(LAYER_NPC, y*16+x, CMB_NPC_HIDDEN);
								}
							}
						}
					}
					Quit();
				}
			}
			
			canItemCheck = false;
			
			//Handles animation for turning NPCs
			if(Type==NPCBT_FACELINK&&(Link->X>0&&Link->X<240&&Link->Y>0&&Link->Y<160)){
				if(Distance(CenterLinkX(), CenterLinkY(), CenterX(this), CenterY(this))<Arg2)
					this->Data = Combo + AngleDir4(Angle(CenterX(this), CenterY(this), CenterLinkX(), CenterLinkY()));
				else
					this->Data = Combo + Arg1;
			}
			
			//Handles movement for guard NPCs
			else if(Type==NPCBT_GUARDH){
				if(Link->X>16*Arg1-32&&Link->X<16*Arg2+32&&Link->Y>this->Y-32&&Link->Y<this->Y+32){
					this->X = Clamp(this->X+(-this->X + Link->X)/4, 16*Arg1, 16*Arg2);
				}
			}
			else if(Type==NPCBT_GUARDV){
				if(Link->X>this->X-32&&Link->X<this->X+32&&Link->Y>16*Arg1-32&&Link->Y<16*Arg2+32){
					this->Y = Clamp(this->Y+(-this->Y + Link->Y)/4, 16*Arg1, 16*Arg2);
				}
			}
			
			int dialogueBox1[] = "DialogueBranch_Simple";
			int dialogueBox2[] = "DialogueBranch_Advanced";
			int scrDB1 = Game->GetFFCScript(dialogueBox1);
			int scrDB2 = Game->GetFFCScript(dialogueBox2);
			
			
			bool noTalk;
			if(CountFFCsRunning(scrDB1)>0)
				noTalk = true;
			if(CountFFCsRunning(scrDB2)>0)
				noTalk = true;
			
			//Facing Up
			if(!noTalk&&Link->Dir==DIR_UP&&Link->Y>=this->Y&&Link->Y<=this->Y+Height-8&&Link->X>=this->X-8&&Link->X<=this->X+Width-8){
				if(CMB_NPC_CANTALK>0)
					Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				if(Link->PressA){
					Link->InputA = false;
					Link->PressA = false;
					Screen->Message(String);
					if(Script>0){
						int args[8] = {ScriptArg};
						int i = RunFFCScript(Script, args);
						if(NPCSCRIPT_WAITS_UNTIL_SCRIPTS_FINISH){
							ffc f = Screen->LoadFFC(i);
							while(f->Script==Script){
								Waitframe();
							}
						}
					}
				}
			}
			//Facing Down
			else if(!noTalk&&Link->Dir==DIR_DOWN&&Link->Y>=this->Y-16&&Link->Y<=this->Y+Height-16&&Link->X>=this->X-8&&Link->X<=this->X+Width-8){
				if(CMB_NPC_CANTALK>0)
					Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				if(Link->PressA){
					Link->InputA = false;
					Link->PressA = false;
					Screen->Message(String);
					if(Script>0){
						int args[8] = {ScriptArg};
						int i = RunFFCScript(Script, args);
						if(NPCSCRIPT_WAITS_UNTIL_SCRIPTS_FINISH){
							ffc f = Screen->LoadFFC(i);
							while(f->Script==Script){
								Waitframe();
							}
						}
					}
				}
			}
			//Facing Left
			else if(!noTalk&&Link->Dir==DIR_LEFT&&Link->Y>=this->Y-8&&Link->Y<=this->Y+Height-8&&Link->X>=this->X&&Link->X<=this->X+Width){
				if(CMB_NPC_CANTALK>0)
					Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				if(Link->PressA){
					Link->InputA = false;
					Link->PressA = false;
					Screen->Message(String);
					if(Script>0){
						int args[8] = {ScriptArg};
						int i = RunFFCScript(Script, args);
						if(NPCSCRIPT_WAITS_UNTIL_SCRIPTS_FINISH){
							ffc f = Screen->LoadFFC(i);
							while(f->Script==Script){
								Waitframe();
							}
						}
					}
				}
			}
			//Facing Right
			else if(!noTalk&&Link->Dir==DIR_RIGHT&&Link->Y>=this->Y-8&&Link->Y<=this->Y+Height-8&&Link->X>=this->X-16&&Link->X<=this->X+Width-16){
				if(CMB_NPC_CANTALK>0)
					Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				if(Link->PressA){
					Link->InputA = false;
					Link->PressA = false;
					Screen->Message(String);
					if(Script>0){
						int args[8] = {ScriptArg};
						int i = RunFFCScript(Script, args);
						if(NPCSCRIPT_WAITS_UNTIL_SCRIPTS_FINISH){
							ffc f = Screen->LoadFFC(i);
							while(f->Script==Script){
								Waitframe();
							}
						}
					}
				}
			}
			Waitframe();
		}
	}
}

ffc script NPCScript_Simple{
	void run(int String, int Script, int D0, int D1, int D2, int D3, int D4, int D5){
		//Saves the width and height of the FFC for collision checks
		int Width = 16;
		int Height = 16;
		if(this->EffectWidth!=16)
			Width = this->EffectWidth;
		else if(this->TileWidth>1)
			Width = this->TileWidth*16;
		if(this->EffectHeight!=16)
			Height = this->EffectHeight;
		else if(this->TileHeight>1)
			Height = this->TileHeight*16;
		while(true){
			int dialogueBox1[] = "DialogueBranch_Simple";
			int dialogueBox2[] = "DialogueBranch_Advanced";
			int scrDB1 = Game->GetFFCScript(dialogueBox1);
			int scrDB2 = Game->GetFFCScript(dialogueBox2);
			
			bool noTalk;
			if(CountFFCsRunning(scrDB1)>0)
				noTalk = true;
			if(CountFFCsRunning(scrDB2)>0)
				noTalk = true;
			
			//Facing Up
			if(!noTalk&&Link->Dir==DIR_UP&&Link->Y>=this->Y&&Link->Y<=this->Y+Height-8&&Link->X>=this->X-8&&Link->X<=this->X+Width-8){
				if(CMB_NPC_CANTALK>0)
					Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				if(Link->PressA){
					Link->InputA = false;
					Link->PressA = false;
					Screen->Message(String);
					if(Script>0){
						int Args[8] = {D0, D1, D2, D3, D4, D5};
						int i = RunFFCScript(Script, Args);
						if(NPCSCRIPT_WAITS_UNTIL_SCRIPTS_FINISH){
							ffc f = Screen->LoadFFC(i);
							while(f->Script==Script){
								Waitframe();
							}
						}
					}
				}
			}
			//Facing Down
			else if(!noTalk&&Link->Dir==DIR_DOWN&&Link->Y>=this->Y-16&&Link->Y<=this->Y+Height-16&&Link->X>=this->X-8&&Link->X<=this->X+Width-8){
				if(CMB_NPC_CANTALK>0)
					Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				if(Link->PressA){
					Link->InputA = false;
					Link->PressA = false;
					Screen->Message(String);
					if(Script>0){
						int Args[8] = {D0, D1, D2, D3, D4, D5};
						int i = RunFFCScript(Script, Args);
						if(NPCSCRIPT_WAITS_UNTIL_SCRIPTS_FINISH){
							ffc f = Screen->LoadFFC(i);
							while(f->Script==Script){
								Waitframe();
							}
						}
					}
				}
			}
			//Facing Left
			else if(!noTalk&&Link->Dir==DIR_LEFT&&Link->Y>=this->Y-8&&Link->Y<=this->Y+Height-8&&Link->X>=this->X&&Link->X<=this->X+Width){
				if(CMB_NPC_CANTALK>0)
					Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				if(Link->PressA){
					Link->InputA = false;
					Link->PressA = false;
					Screen->Message(String);
					if(Script>0){
						int Args[8] = {D0, D1, D2, D3, D4, D5};
						int i = RunFFCScript(Script, Args);
						if(NPCSCRIPT_WAITS_UNTIL_SCRIPTS_FINISH){
							ffc f = Screen->LoadFFC(i);
							while(f->Script==Script){
								Waitframe();
							}
						}
					}
				}
			}
			//Facing Right
			else if(!noTalk&&Link->Dir==DIR_RIGHT&&Link->Y>=this->Y-8&&Link->Y<=this->Y+Height-8&&Link->X>=this->X-16&&Link->X<=this->X+Width-16){
				if(CMB_NPC_CANTALK>0)
					Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				if(Link->PressA){
					Link->InputA = false;
					Link->PressA = false;
					Screen->Message(String);
					if(Script>0){
						int Args[8] = {D0, D1, D2, D3, D4, D5};
						int i = RunFFCScript(Script, Args);
						if(NPCSCRIPT_WAITS_UNTIL_SCRIPTS_FINISH){
							ffc f = Screen->LoadFFC(i);
							while(f->Script==Script){
								Waitframe();
							}
						}
					}
				}
			}
			Waitframe();
		}
	}
}

ffc script TradeSequence{
	void run(int CheckItem, int TradeItem, int NoItemString, int HasItemString, int TradedString){
		//Check if the player has already traded
		if(Screen->D[D_TRADE]==0){
			//If player hasn't traded and has the required item, play HasItemString, give the new item, and take the old item
			if(Link->Item[CheckItem]){
				Screen->Message(HasItemString);
				WaitNoAction();
				item itm = CreateItemAt(TradeItem, Link->X, Link->Y);
				itm->Pickup = IP_HOLDUP;
				Link->Item[CheckItem] = false;
				Screen->D[D_TRADE] = 1;
				WaitNoAction();
			}
			//If player hasn't traded and doesn't have the required item, play NoItemString
			else{
				Screen->Message(NoItemString);
				WaitNoAction();
			}
		}
		//If the player has already traded, play TradedString
		else{
			Screen->Message(TradedString);
			WaitNoAction();
		}
	}
}

ffc script GBCliff{
	bool CheckCliffDirection(int Combo){
		int Dir;
		if(Screen->ComboS[Combo]==0101b)
			Dir = DIR_UP;
		else if(Screen->ComboS[Combo]==1010b)
			Dir = DIR_DOWN;
		else if(Screen->ComboS[Combo]==0011b)
			Dir = DIR_LEFT;
		else if(Screen->ComboS[Combo]==1100b)
			Dir = DIR_RIGHT;
		else
			return false;
		if(Dir==Link->Dir)
			return true;
		return false;
	}
	void run(){
		int PushCounter = 0;
		while(true){
			if(Link->Dir==DIR_UP&&!CanWalk(Link->X, Link->Y, DIR_UP, 1, false)&&Link->InputUp&&Screen->ComboT[ComboAt(Link->X+8, Link->Y+14)]==CT_CLIFF&&CheckCliffDirection(ComboAt(Link->X+8, Link->Y+14))&&(Link->Action==LA_WALKING||Link->Action==LA_NONE)){
				PushCounter++;
				if(PushCounter>=CLIFF_PAUSE){
					Game->PlaySound(SFX_JUMP);
					Link->Jump = 2;
					int Y = Link->Y;
					for(int i=0; i<26; i++){
						Y -= 0.61;
						Link->Y = Y;
						WaitNoAction();
					}
					PushCounter = 0;
				}
			}
			else if(Link->Dir==DIR_DOWN&&!CanWalk(Link->X, Link->Y, DIR_DOWN, 1, false)&&Link->InputDown&&Screen->ComboT[ComboAt(Link->X+8, Link->Y+12)]==CT_CLIFF&&CheckCliffDirection(ComboAt(Link->X+8, Link->Y+12))&&(Link->Action==LA_WALKING||Link->Action==LA_NONE)){
				PushCounter++;
				if(PushCounter>=CLIFF_PAUSE){
					Game->PlaySound(SFX_JUMP);
					Link->Jump = 1;
					int Combo = ComboAt(Link->X+8, Link->Y+12);
					int CliffHeight = 1;
					for(int i=1; i<11; i++){
						if(Screen->isSolid(ComboX(Combo)+8, ComboY(Combo)+8+16*i))
							CliffHeight++;
						else
							break;
					}
					Link->Z = CliffHeight*16;
					Link->Y += CliffHeight*16;
					while(Link->Z>0){
						WaitNoAction();
					}
					PushCounter = 0;
				}
			}
			else if(Link->Dir==DIR_LEFT&&!CanWalk(Link->X, Link->Y, DIR_LEFT, 1, false)&&Link->InputLeft&&Screen->ComboT[ComboAt(Link->X+4, Link->Y+8)]==CT_CLIFF&&CheckCliffDirection(ComboAt(Link->X+4, Link->Y+8))&&(Link->Action==LA_WALKING||Link->Action==LA_NONE)){
				PushCounter++;
				if(PushCounter>=CLIFF_PAUSE){
					Game->PlaySound(SFX_JUMP);
					Link->Jump = 2;
					int X = Link->X;
					for(int i=0; i<26; i++){
						X -= 0.92;
						if(i==13){
							Link->Z += 16;
							Link->Y += 16;
						}
						Link->X = X;
						WaitNoAction();
					}
					while(Link->Z>0){
						WaitNoAction();
					}
					PushCounter = 0;
				}
			}
			else if(Link->Dir==DIR_RIGHT&&!CanWalk(Link->X, Link->Y, DIR_RIGHT, 1, false)&&Link->InputRight&&Screen->ComboT[ComboAt(Link->X+12, Link->Y+8)]==CT_CLIFF&&CheckCliffDirection(ComboAt(Link->X+12, Link->Y+8))&&(Link->Action==LA_WALKING||Link->Action==LA_NONE)){
				PushCounter++;
				if(PushCounter>=CLIFF_PAUSE){
					Game->PlaySound(SFX_JUMP);
					Link->Jump = 2;
					int X = Link->X;
					for(int i=0; i<26; i++){
						X += 0.92;
						if(i==13){
							Link->Z += 16;
							Link->Y += 16;
						}
						Link->X = X;
						WaitNoAction();
					}
					while(Link->Z>0){
						WaitNoAction();
					}
					PushCounter = 0;
				}
			}
			else{
				PushCounter = 0;
			}
			Waitframe();
		}
	}
}

ffc script GBDungeonCliff{
	void run(int CliffCombo){
		int PushCounter = 0;
		while(true){
			if(Link->Dir==DIR_UP&&!CanWalk(Link->X, Link->Y, DIR_UP, 1, false)&&Link->InputUp&&Screen->ComboD[ComboAt(Link->X+8, Link->Y+7)]==CliffCombo&&(Link->Action==LA_WALKING||Link->Action==LA_NONE)){
				PushCounter++;
				if(PushCounter>=CLIFF_PAUSE){
					Game->PlaySound(SFX_JUMP);
					Link->Jump = 2;
					int Y = Link->Y;
					for(int i=0; i<26; i++){
						Y -= 0.92;
						Link->Y = Y;
						WaitNoAction();
					}
					PushCounter = 0;
				}
			}
			else if(Link->Dir==DIR_DOWN&&!CanWalk(Link->X, Link->Y, DIR_DOWN, 1, false)&&Link->InputDown&&Screen->ComboD[ComboAt(Link->X+8, Link->Y+16)]==CliffCombo+1&&(Link->Action==LA_WALKING||Link->Action==LA_NONE)){
				PushCounter++;
				if(PushCounter>=CLIFF_PAUSE){
					Game->PlaySound(SFX_JUMP);
					Link->Jump = 1;
					int Combo = ComboAt(Link->X+8, Link->Y+12);
					int CliffHeight = 1;
					for(int i=1; i<11; i++){
						if(Screen->isSolid(ComboX(Combo)+8, ComboY(Combo)+8+16*i))
							CliffHeight++;
						else
							break;
					}
					Link->Z = CliffHeight*16-8;
					Link->Y += CliffHeight*16-8;
					while(Link->Z>0){
						WaitNoAction();
					}
					PushCounter = 0;
				}
			}
			else if(Link->Dir==DIR_LEFT&&!CanWalk(Link->X, Link->Y, DIR_LEFT, 1, false)&&Link->InputLeft&&Screen->ComboD[ComboAt(Link->X-1, Link->Y+8)]==CliffCombo+2&&(Link->Action==LA_WALKING||Link->Action==LA_NONE)){
				PushCounter++;
				if(PushCounter>=CLIFF_PAUSE){
					Game->PlaySound(SFX_JUMP);
					Link->Jump = 2;
					int X = Link->X;
					for(int i=0; i<26; i++){
						X -= 1.23;
						Link->X = X;
						WaitNoAction();
					}
					PushCounter = 0;
				}
			}
			else if(Link->Dir==DIR_RIGHT&&!CanWalk(Link->X, Link->Y, DIR_RIGHT, 1, false)&&Link->InputRight&&Link->InputRight&&Screen->ComboD[ComboAt(Link->X+16, Link->Y+8)]==CliffCombo+3&&(Link->Action==LA_WALKING||Link->Action==LA_NONE)){
				PushCounter++;
				if(PushCounter>=CLIFF_PAUSE){
					Game->PlaySound(SFX_JUMP);
					Link->Jump = 2;
					int X = Link->X;
					for(int i=0; i<26; i++){
						X += 1.23;
						Link->X = X;
						WaitNoAction();
					}
				}
			}
			else{
				PushCounter = 0;
			}
			Waitframe();
		}
	}
}

//This is the main item script which calls the other two FFCs when the item is used
item script MooshItem{
	void run(int dummy, int ID_mpCost, int type_step, int wType_maxShot, int arg1_arg2, int arg3_arg4, int sprite_sfx, int flags){
		int handler[] = "MooshItem_Handler";
		int anim[] = "MooshItem_Animations";
		
		int type = MooshItem_LeftArg(type_step);
		int maxShot = MooshItem_RightArg(wType_maxShot);
		//Attacks that drain the MP bar over time can't be used twice on a screen
		if(flags&MIF_DRAINMP) 
			maxShot = 0;
		
		int args[8];
		int ID = MooshItem_LeftArg(ID_mpCost);
		int mpCost = MooshItem_RightArg(ID_mpCost);
		
		//Prevent the script running by holding the item button
		if(!MooshItem_PressButtonItem(ID))
			Quit();
		//Prevent the script running if not enough MP (charge shot is an exception)
		if(!MooshItem_CanTakeResource(ID, mpCost)&&type!=4)
			Quit();
		if(MooshItem_NumType(type)<=maxShot){
			if(flags&MIF_ANIMSTAB||flags&MIF_ANIMSLASH){
				//Stab + Slash = Z3 slash
				if(flags&MIF_ANIMSTAB&&flags&MIF_ANIMSLASH)
					args[0] = 2;
				else if(flags&MIF_ANIMSLASH)
					args[0] = 1;
				else
					args[0] = 0;
				args[1] = ID_mpCost;
				args[2] = type_step;
				args[3] = wType_maxShot;
				args[4] = arg1_arg2;
				args[5] = arg3_arg4;
				args[6] = sprite_sfx;
				args[7] = flags;
				RunFFCScript(Game->GetFFCScript(anim), args);
			}
			else{
				Link->Action = LA_ATTACKING;
				args[0] = ID_mpCost;
				args[1] = type_step;
				args[2] = wType_maxShot;
				args[3] = arg1_arg2;
				args[4] = arg3_arg4;
				args[5] = sprite_sfx;
				args[6] = flags;
				RunFFCScript(Game->GetFFCScript(handler), args);
			}
		}
	}
	bool MooshItem_CanTakeResource(int ID, int mpCost){
		if(mpCost==0)
			return true;
		itemdata itemdat = Game->LoadItemData(ID);
		if(itemdat->Counter>-1){ //If a counter is set
			if(itemdat->Counter==CR_LIFE){ //If the counter is health, don't allow it to hit 0
				if(Game->Counter[itemdat->Counter]<=mpCost)
					return false;
			}
			else if(Game->Counter[itemdat->Counter]<mpCost)
				return false;
		}
		else{ //Otherwise it's a regular magic cost
			//Only magic costs are affected by 1/2 magic
			mpCost = mpCost*Game->Generic[GEN_MAGICDRAINRATE];
			if(Link->MP<mpCost)
				return false;
		}
		return true;
	}
}

//Returns the component of an argument left of the decimal point
int MooshItem_LeftArg(float i){
	return Floor(i);
}

//Returns the component of an argument right of the decimal point
int MooshItem_RightArg(float i){
	int left = MooshItem_LeftArg(i);
	return (i-left)*10000;
}

//Count the number of active weapon scripts of a certain type
int MooshItem_NumType(int checktype){
	int handler[] = "MooshItem_Handler";
	int slot = Game->GetFFCScript(handler);
	
	int count;
	for(int i=1; i<=32; i++){
		ffc f = Screen->LoadFFC(i);
		if(f->Script==slot){
			int type = MooshItem_LeftArg(f->InitD[1]);
			if(type==checktype)
				count++;
		}
	}
	return count;
}

//Returns true if Link is pressing an item's button that frame
bool MooshItem_PressButtonItem(int id){
	return (GetEquipmentA()==id&&Link->PressA)||(GetEquipmentB()==id&&Link->PressB);
}

//Returns true if Link is holding down an item's button
bool MooshItem_InputButtonItem(int id){
	return (GetEquipmentA()==id&&Link->InputA)||(GetEquipmentB()==id&&Link->InputB);
}

//Get the difference between two angles in degrees
int MooshItem_AngDiff(int angle1, int angle2){
	
	// Get the difference between the two angles
	float dif = WrapDegrees(angle2) - WrapDegrees(angle1);
	
	// Compensate for the difference being outside of normal bounds
	if(dif >= 180)
		dif -= 360;
	else if(dif <= -1 * 180)
		dif += 360;
		
	return dif;
}

//This FFC script contains most of the item behaviors
ffc script MooshItem_Handler{
	void run(int ID_mpCost, int type_step, int wType_maxShot, int arg1_arg2, int arg3_arg4, int sprite_sfx, int flags){
		int i; int j; int k; int m;
		int x; int y;
		
		//First we split a bunch of the arguments into their two halves
		int ID = MooshItem_LeftArg(ID_mpCost);
		int mpCost = MooshItem_RightArg(ID_mpCost);
		
		int type = MooshItem_LeftArg(type_step);
		int step = MooshItem_RightArg(type_step);
		
		int wType = MooshItem_LeftArg(wType_maxShot);
		if(wType==0)
			wType = LW_SCRIPT1;
		int maxShot = MooshItem_RightArg(wType_maxShot);
		
		int arg1 = MooshItem_LeftArg(arg1_arg2);
		int arg2 = MooshItem_RightArg(arg1_arg2);
		
		int arg3 = MooshItem_LeftArg(arg3_arg4);
		int arg4 = MooshItem_RightArg(arg3_arg4);
		
		int sprite = MooshItem_LeftArg(sprite_sfx);
		int sfx = MooshItem_RightArg(sprite_sfx);
		
		itemdata itemdat = Game->LoadItemData(ID);
		
		if(type!=4){ //Charge shot calculates MP differently
			//Take MP / Counter if applicable
			if(!MooshItem_CanTakeResource(ID, mpCost))
				Quit();
			else
				MooshItem_TakeResource(ID, mpCost);
		}
		
		//Get Link's direction
		int LinkAng;
		int angle;
		if(Link->Dir==DIR_UP)
			LinkAng = -90;
		else if(Link->Dir==DIR_DOWN)
			LinkAng = 90;
		else if(Link->Dir==DIR_LEFT)
			LinkAng = 180;
		//Update the direction if the weapon has 8-way aiming
		if(flags&MIF_8WAYAIM){
			LinkAng = MooshItem_8WayAimAngle(LinkAng);
		}
		
		//Look at all this garbage!
		lweapon lgroup[256];
		lweapon l;
		int lTimer[256];
		int lTile[256];
		int lAng[256];
		int lType[256];
		int lMisc1[256];
		int lMisc2[256];
		int lDecay[256];
		int lFlags[256];
		int lACounter[256];
		int lNumFrames[256];
		int lASpeed[256];
		int lBombSP[256];
		int lLastX[256];
		int lLastY[256];
		int vars[17] = {0, lTimer, lTile, lAng, lType, lMisc1, lMisc2, lDecay, lFlags, lACounter, lNumFrames, lASpeed, 0, lLastX, lLastY, itemdat->Power*2, 0};
		
		//Bomb blasts get converted into a weapon with no collsion that regularly drops them
		if(wType==LW_BOMBBLAST){
			wType = LW_MOOSHITEM_MELEE;
			vars[12] = 1;
		}
		else if(wType==LW_SBOMBBLAST){
			wType = LW_MOOSHITEM_MELEE;
			vars[12] = 2;
		}
		
		if(type==0){ //Normal (V)
			//Arg 1 = Decay
			//Arg 2 = NumShots
			//Arg 3 = Spread
			//Arg 4 = Step 2
			if(arg2==0)
				arg2 = 1;
			if(arg3==0&&arg2>1)
				arg3 = 60;
			if(arg4==0)
				arg4 = step;
				
			x = Link->X+VectorX(12, LinkAng);
			y = Link->Y+VectorY(12, LinkAng);
			for(i=0; i<arg2; i++){
				angle = LinkAng-arg3/2+(i/(arg2-1))*arg3;
				if(arg2==1)
					angle = LinkAng;
				l = MooshItem_FireLWeapon(wType, x, y, angle, step-(step-arg4)*Abs((i/(arg2-1)*2)-1), itemdat->Power*2, sprite, sfx, flags);
				j = MooshItem_AddLWeapon(vars, lgroup, l, 0, angle, flags);
				lDecay[j] = arg1;
			}
			while(vars[0]>0){
				MooshItem_UpdateLWeapons(vars, lgroup);
				Waitframe();
			}
		}
		else if(type==1){ //Normal (Line)
			//Arg 1 = Decay
			//Arg 2 = NumShots
			//Arg 3 = Spread
			//Arg 4 = Step 2
			if(arg2==0)
				arg2 = 1;
			if(arg4==0)
				arg4 = step;
				
			x = Link->X+VectorX(12, LinkAng);
			y = Link->Y+VectorY(12, LinkAng);
			for(i=0; i<arg2; i++){
				angle = LinkAng+Rand(-arg3/2, arg3/2);
				if(arg2==1)
					angle = LinkAng;
				l = MooshItem_FireLWeapon(wType, x, y, angle, step-(step-arg4)*(i/(arg2-1)), itemdat->Power*2, sprite, sfx, flags);
				j = MooshItem_AddLWeapon(vars, lgroup, l, 0, angle, flags);
				lDecay[j] = arg1;
			}
			while(vars[0]>0){
				MooshItem_UpdateLWeapons(vars, lgroup);
				Waitframe();
			}
		}
		else if(type==2){ //Sine Wave
			//Arg 1 = Amplitude
			//Arg 2 = Frequency
			//Arg 3 = NumShots
			//Arg 4 = Repeat
			if(arg1==0)
				arg1 = 16;
			if(arg2==0)
				arg2 = 32;
			if(arg3==0)
				arg3 = 1;
			do{
				for(i=0; i<arg3; i++){
					LinkAng = 0;
					if(Link->Dir==DIR_UP)
						LinkAng = -90;
					else if(Link->Dir==DIR_DOWN)
						LinkAng = 90;
					else if(Link->Dir==DIR_LEFT)
						LinkAng = 180;
					if(flags&MIF_8WAYAIM){
						LinkAng = MooshItem_8WayAimAngle(LinkAng);
					}
					x = Link->X+VectorX(12, LinkAng);
					y = Link->Y+VectorY(12, LinkAng);
					l = MooshItem_FireLWeapon(wType, x, y, LinkAng, step, itemdat->Power*2, sprite, sfx, flags);
					j = MooshItem_AddLWeapon(vars, lgroup, l, 1, angle, flags);
					lMisc1[j] = (Cond(i%2==0, 1, -1)*(arg1+Floor(i/2)*16))/2;
					lMisc2[j] = arg2;
					lTimer[j] += (45/arg2*(step/100))*Floor(i/2);
				}
				if(arg4>0){
					k = 16/(step/100);
					for(j=0; j<k; j++){
						MooshItem_UpdateLWeapons(vars, lgroup);
						NoAction();
						Waitframe();
					}
				}
				arg4--;
			}while(arg4>0)
				
			while(vars[0]>0){
				MooshItem_UpdateLWeapons(vars, lgroup);
				Waitframe();
			}
		}
		else if(type==3){ //Homing
			//Arg 1 = Decay
			//Arg 2 = TurnSpeed
			//Arg 3 = NumShots
			//Arg 4 = Spread
			if(arg2==0)
				arg2 = 100;
			if(arg4==0)
				arg4 = 60;
				
			x = Link->X+VectorX(12, LinkAng);
			y = Link->Y+VectorY(12, LinkAng);
			for(i=0; i<arg3; i++){
				angle = LinkAng-arg4/2+(i/(arg3-1))*arg4;
				if(arg3==1)
					angle = LinkAng;
				l = MooshItem_FireLWeapon(wType, x, y, angle, step, itemdat->Power*2, sprite, sfx, flags);
				j = MooshItem_AddLWeapon(vars, lgroup, l, 2, angle, flags);
				lDecay[j] = arg1;
				lMisc1[j] = arg2;
			}
			while(vars[0]>0){
				MooshItem_UpdateLWeapons(vars, lgroup);
				Waitframe();
			}
		}
		else if(type==4){ //Charge shot
			//Arg 1 = Charge time
			//Arg 2 = Charge Type: 0 - 2x2 weapon, 1 - spread shot, 2 - homing shots
			//Arg 3 = Sprite
			//Arg 4 = Damage
			if(arg1==0)
				arg1 = 90;
			int chargeCounter = 0;
			while(MooshItem_InputButtonItem(ID)){
				i = (i+1)%360;
				if(i%3==0){
					Link->InputUp = false;
					Link->InputDown = false;
					Link->InputLeft = false;
					Link->InputRight = false;
				}
				if(!MooshItem_CanTakeResource(ID, mpCost))
					chargeCounter = 0;
				if(chargeCounter<arg1){
					chargeCounter++;
					if(chargeCounter==arg1)
						Game->PlaySound(SFX_MOOSHITEM_CHARGE);
				}
				else{
					DrawTile(3, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset-Link->Z, Link->Tile, 1, 1, 9-((Floor(i/2)%32)>>1), -1, -1, 0, 0, 0, Link->Flip, true, 128);
				}
				Waitframe();
			}
			LinkAng = 0;
			if(Link->Dir==DIR_UP)
				LinkAng = -90;
			else if(Link->Dir==DIR_DOWN)
				LinkAng = 90;
			else if(Link->Dir==DIR_LEFT)
				LinkAng = 180;
			if(flags&MIF_8WAYAIM){
				LinkAng = MooshItem_8WayAimAngle(LinkAng);
			}
			x = Link->X+VectorX(12, LinkAng);
			y = Link->Y+VectorY(12, LinkAng);
			if(chargeCounter<arg1){
				l = MooshItem_FireLWeapon(wType, x, y, LinkAng, step, itemdat->Power*2, sprite, sfx, flags);
				j = MooshItem_AddLWeapon(vars, lgroup, l, 0, angle, flags);
			}
			else{
				if(!MooshItem_CanTakeResource(ID, mpCost))
					Quit();
				else
					MooshItem_TakeResource(ID, mpCost);
				if(arg2==0){ //Big shot
					l = MooshItem_FireLWeapon(wType, x, y, LinkAng, step, arg4*2, arg3, sfx, flags|MIF_2X2);
					j = MooshItem_AddLWeapon(vars, lgroup, l, 0, angle, flags|MIF_2X2);
				}
				else if(arg2==1){ //Spread shot
					if(arg3==0)
						arg3 = 3;
					if(arg4==0)
						arg4 = 45;
					for(i=0; i<12; i++){
						angle = LinkAng-arg4/2+(i/(12-1))*arg4;
						l = MooshItem_FireLWeapon(wType, x, y, angle, step, arg4*2, arg3, sfx, flags);
						j = MooshItem_AddLWeapon(vars, lgroup, l, 0, angle, flags);
					}
				}
				else if(arg2==2){ //Homing
					for(i=0; i<12; i++){
						angle = LinkAng+(360/12)*i;
						l = MooshItem_FireLWeapon(wType, x, y, angle, step, arg4*2, arg3, sfx, flags);
						j = MooshItem_AddLWeapon(vars, lgroup, l, 2, angle, flags);
						lMisc1[j] = 1000;
					}
				}
			}
			while(vars[0]>0){
				MooshItem_UpdateLWeapons(vars, lgroup);
				Waitframe();
			}
		}
		else if(type==5){ //Circular Shield
			//Arg 1 = NumShots
			//Arg 2 = Distance
			//Arg 3 = AngOffset
			//Arg 4 = BlockFlags
			if(arg1==0)
				arg1 = 6;
			if(arg2==0)
				arg2 = 24;
			if(MooshItem_NumType(type)>1){
				arg2 += Max(8, arg2-16)*MooshItem_NumType(type);
				if(MooshItem_NumType(type)%2==0){
					step = -step;
					arg3 = -arg3;
				}
			}
			x = Link->X;
			y = Link->Y;
			vars[16] = 1;
			for(i=0; i<arg1; i++){
				l = MooshItem_FireLWeapon(wType, x, y, 0, 0, itemdat->Power*2, sprite, sfx, flags);
				j = MooshItem_AddLWeapon(vars, lgroup, l, 3, 0, flags);
				lMisc1[j] = arg4;
			}
			for(j=0; j<16; j++){
				LinkAng = WrapDegrees(LinkAng+step/100);
				for(i=0; i<arg1; i++){
					x = Link->X;
					y = Link->Y;
					if(lgroup[i]->isValid()){
						lgroup[i]->HitXOffset = VectorX(arg2*(j/16), LinkAng+360/arg1*i+arg3); 
						lgroup[i]->HitYOffset = VectorY(arg2*(j/16), LinkAng+360/arg1*i);
						lgroup[i]->DrawXOffset = lgroup[i]->HitXOffset;
						lgroup[i]->DrawYOffset = lgroup[i]->HitYOffset;
						lgroup[i]->X = x;
						lgroup[i]->Y = y;
						lgroup[i]->Z = Link->Z;
						if(arg3<=0)
							lAng[i] = LinkAng+360/arg1*i+90;
						else
							lAng[i] = LinkAng+360/arg1*i-90;
					}
				}
				MooshItem_UpdateLWeapons(vars, lgroup);
				Waitframe();
			}
			k = 0;
			while(vars[0]>0){
				if(flags&MIF_DRAINMP){
					k++;
					if(k>=MOOSHITEM_MP_DRAIN_FREQ){
						k = 0;
						if(MooshItem_CanTakeResource(ID, Max(1, mpCost*MOOSHITEM_MP_DRAIN_RATIO)))
							MooshItem_TakeResource(ID, Max(1, mpCost*MOOSHITEM_MP_DRAIN_RATIO));
						else
							break;
					}
					if(MooshItem_PressButtonItem(ID)){
						NoAction();
						break;
					}
				}
				LinkAng = WrapDegrees(LinkAng+step/100);
				int activeWeapons = 0;
				for(i=0; i<arg1; i++){
					x = Link->X; 
					y = Link->Y; 
					if(lgroup[i]->isValid()){
						lgroup[i]->HitXOffset = VectorX(arg2, LinkAng+360/arg1*i+arg3); 
						lgroup[i]->HitYOffset = VectorY(arg2, LinkAng+360/arg1*i);
						lgroup[i]->DrawXOffset = lgroup[i]->HitXOffset;
						lgroup[i]->DrawYOffset = lgroup[i]->HitYOffset;
						lgroup[i]->X = x;
						lgroup[i]->Y = y;
						lgroup[i]->Z = Link->Z;
						if(arg3<=0)
							lAng[i] = LinkAng+360/arg1*i+90;
						else
							lAng[i] = LinkAng+360/arg1*i-90;
						//Count how many of the weapons are still alive.
						//This is to fix a bug that was caused by another bugfix.
						activeWeapons++;
					}
				}
				if(activeWeapons==0)
					break;
				MooshItem_UpdateLWeapons(vars, lgroup);
				Waitframe();
			}
			for(j=0; j<16; j++){
				LinkAng = WrapDegrees(LinkAng+step/100);
				for(i=0; i<arg1; i++){
					x = Link->X;
					y = Link->Y;
					if(lgroup[i]->isValid()){
						lgroup[i]->HitXOffset = VectorX(arg2-arg2*(j/16), LinkAng+360/arg1*i+arg3); 
						lgroup[i]->HitYOffset = VectorY(arg2-arg2*(j/16), LinkAng+360/arg1*i);
						lgroup[i]->DrawXOffset = lgroup[i]->HitXOffset;
						lgroup[i]->DrawYOffset = lgroup[i]->HitYOffset;
						lgroup[i]->X = x;
						lgroup[i]->Y = y;
						lgroup[i]->Z = Link->Z;
						if(arg3<=0)
							lAng[i] = LinkAng+360/arg1*i+90;
						else
							lAng[i] = LinkAng+360/arg1*i-90;
					}
				}
				MooshItem_UpdateLWeapons(vars, lgroup);
				Waitframe();
			}
			for(i=0; i<arg1; i++){
				if(lgroup[i]->isValid())
					lgroup[i]->DeadState = 0;
			}
		}
		else if(type==6){ //Breath
			//Arg 1 = Decay
			//Arg 2 = Spread
			//Arg 3 = Special Firing
			//Arg 4 = Special Arg
			k = 0;
			m = 0;
			do{
				if(flags&MIF_DRAINMP){
					k++;
					if(k>=MOOSHITEM_MP_DRAIN_FREQ){
						k = 0;
						if(MooshItem_CanTakeResource(ID, Max(1, mpCost*MOOSHITEM_MP_DRAIN_RATIO)))
							MooshItem_TakeResource(ID, Max(1, mpCost*MOOSHITEM_MP_DRAIN_RATIO));
						else
							break;
					}
				}
				m++;
				if(m>=4){
					m = 0;
					
					LinkAng = 0;
					if(Link->Dir==DIR_UP)
						LinkAng = -90;
					else if(Link->Dir==DIR_DOWN)
						LinkAng = 90;
					else if(Link->Dir==DIR_LEFT)
						LinkAng = 180;
					if(flags&MIF_8WAYAIM){
						LinkAng = MooshItem_8WayAimAngle(LinkAng);
					}
					
					x = Link->X+VectorX(12, LinkAng);
					y = Link->Y+VectorY(12, LinkAng);
					if(arg3==0){ //Normal shot
						if(arg4==0)
							arg4 = step;
						angle = LinkAng+Rand(-arg2/2, arg2/2);
						l = MooshItem_FireLWeapon(wType, x, y, angle, Rand(arg4, step), itemdat->Power*2, sprite, sfx, flags);
						j = MooshItem_AddLWeapon(vars, lgroup, l, 0, angle, flags);
						lDecay[j] = arg1;
					}
					else if(arg3==1){ //Sine Wave
						if(arg4==0)
							arg4 = 16;
						angle = LinkAng+Rand(-arg2/2, arg2/2);
						l = MooshItem_FireLWeapon(wType, x, y, angle, step, itemdat->Power*2, sprite, sfx, flags);
						j = MooshItem_AddLWeapon(vars, lgroup, l, 1, angle, flags);
						lDecay[j] = arg1;
						lMisc1[j] = arg4*Choose(-1, 1);
						lMisc2[j] = arg4*2;
					}
					else if(arg3==2){ //Homing
						if(arg4==0)
							arg4 = 1000;
						angle = LinkAng+Rand(-arg2/2, arg2/2);
						l = MooshItem_FireLWeapon(wType, x, y, angle, step, itemdat->Power*2, sprite, sfx, flags);
						j = MooshItem_AddLWeapon(vars, lgroup, l, 2, angle, flags);
						lDecay[j] = arg1;
						lMisc1[j] = arg4;
					}
					else if(arg3==3){ //Wall Bounce
						if(arg4==0)
							arg4 = 3;
						angle = LinkAng+Rand(-arg2/2, arg2/2);
						l = MooshItem_FireLWeapon(wType, x, y, angle, step, itemdat->Power*2, sprite, sfx, flags);
						j = MooshItem_AddLWeapon(vars, lgroup, l, 4, angle, flags);
						lDecay[j] = arg1;
						lMisc1[j] = arg4;
					}
				}
				MooshItem_UpdateLWeapons(vars, lgroup);
				NoAction();
				Waitframe();
			}while(MooshItem_InputButtonItem(ID))
			
		while(vars[0]>0){
				MooshItem_UpdateLWeapons(vars, lgroup);
				Waitframe();
			}
		}
		else if(type==7){ //Spread Shield
			//Arg 1 = Decay
			//Arg 2 = NumShots
			//Arg 3 = Spread
			//Arg 4 = BlockFlags
			if(arg2==0)
				arg2 = 1;
			if(arg3==0&&arg2>1)
				arg3 = 60;
			if(arg4==0)
				arg4 = 1023;
				
			x = Link->X+VectorX(12, LinkAng);
			y = Link->Y+VectorY(12, LinkAng);
			for(i=0; i<arg2; i++){
				angle = LinkAng-arg3/2+(i/(arg2-1))*arg3;
				if(arg2==1)
					angle = LinkAng;
				l = MooshItem_FireLWeapon(wType, x, y, angle, step, itemdat->Power*2, sprite, sfx, flags);
				j = MooshItem_AddLWeapon(vars, lgroup, l, 3, angle, flags);
				lDecay[j] = arg1;
				lMisc1[j] = arg4;
			}
			while(vars[0]>0){
				MooshItem_UpdateLWeapons(vars, lgroup);
				Waitframe();
			}
		}
		else if(type==8){ //Bouncing Gem
			//Arg 1 = Decay
			//Arg 2 = NumShots
			//Arg 3 = Spread
			//Arg 4 = Bounces
			x = Link->X+VectorX(12, LinkAng);
			y = Link->Y+VectorY(12, LinkAng);
			for(i=0; i<arg2; i++){
				angle = LinkAng+Rand(-arg3/2, arg3/2);
				k = 0;
				if(arg2>1)
					k = step*(Rand(5)*0.125);
				l = MooshItem_FireLWeapon(wType, x, y, angle, step+k, itemdat->Power*2, sprite, sfx, flags);
				j = MooshItem_AddLWeapon(vars, lgroup, l, 4, angle, flags);
				lDecay[j] = arg1;
				lMisc1[j] = arg4;
			}
			while(vars[0]>0){
				MooshItem_UpdateLWeapons(vars, lgroup);
				Waitframe();
			}
		}
	}
	//This function is used to shoot projectile lweapons used by the script
	lweapon MooshItem_FireLWeapon(int type, int x, int y, int angle, int step, int damage, int sprite, int sfx, int flags){
		lweapon l = CreateLWeaponAt(type, x, y);
		l->Z = Link->Z;
		l->Angular = true;
		l->Angle = DegtoRad(angle);
		l->Dir = AngleDir4(WrapDegrees(angle));
		l->Step = step;
		l->Damage = damage;
		l->UseSprite(sprite);
		//Adjust the hitbox if 2x2
		if(flags&MIF_2X2){
			l->Extend = 3;
			l->HitWidth = 32;
			l->HitHeight = 32;
			l->TileWidth = 2;
			l->TileHeight = 2;
			l->X-=8;
			l->Y-=8;
		}
		Game->PlaySound(sfx);
		return l;
	}
	//This function is the main guts of the script
	//It updates all the weapons every frame
	void MooshItem_UpdateLWeapons(int vars, lweapon lgroup){
		int i; int j; int k; int m; int o;
		int x; int y;
		int dir;
		
		//vars[0] = Total weapons onscreen
		int lTimer = vars[1];
		int lTile = vars[2];
		int lAng = vars[3];
		int lType = vars[4];
		int lMisc1 = vars[5];
		int lMisc2 = vars[6];
		int lDecay = vars[7];
		int lFlags = vars[8];
		int lACounter = vars[9];
		int lNumFrames = vars[10];
		int lASpeed = vars[11];
		//vars[12] = BombSP
		int lLastX = vars[13];
		int lLastY = vars[14];
		//vars[15] = Weapon Damage
		//vars[16] = Prevent weapon clear
		//Only cycle through weapons currently in use to save iterations
		for(i=0; i<vars[0]; i++){
			//If the weapon itself is there, run its behavior
			if(lgroup[i]->isValid()){
				lTimer[i] = (lTimer[i]+1)%360;
				x = lgroup[i]->X;
				y = lgroup[i]->Y;
				if(lType[i]==1){ //Sine Wave
					k = RadtoDeg(lgroup[i]->Angle);
					o = lgroup[i]->Step/100;
					j = lMisc1[i]*Sin((180/lMisc2[i]*o)*lTimer[i]);
					lgroup[i]->HitXOffset = VectorX(j, k+90);
					lgroup[i]->HitYOffset = VectorY(j, k+90);
					//Weapons with -1000 draw offset are being drawn by the script instead of ZC.
					//Thus they don't need draw offsets to be applied.
					if(lgroup[i]->DrawYOffset>-1000){
						lgroup[i]->DrawXOffset = lgroup[i]->HitXOffset;
						lgroup[i]->DrawYOffset = lgroup[i]->HitYOffset;
					}
					//Adding hit offsets to X and Y affects where the script draws them in special cases
					x += lgroup[i]->HitXOffset;
					y += lgroup[i]->HitYOffset;
					//Here we predict the weapon's position in the next frame so 360 rotating ones are angled right
					m = lMisc1[i]*Sin((180/lMisc2[i]*o)*(lTimer[i]+1));
					int nextX = lgroup[i]->X+VectorX(Max(1, o), k)+VectorX(m, k+90);
					int nextY = lgroup[i]->Y+VectorY(Max(1, o), k)+VectorY(m, k+90);
					lAng[i] = Angle(x, y, nextX, nextY);
				}
				else if(lType[i]==2){ //Homing
					k = MooshItem_Homing_TargetAngle(vars, lAng[i], lgroup[i]);
					j = MooshItem_AngDiff(lAng[i], k);
					//If the distance to the target angle is less than the turn speed, turn it
					if(Abs(j)>lMisc1[i]/100){
						lAng[i] = WrapDegrees(lAng[i]+Sign(j)*(lMisc1[i]/100));
					}
					//Otherwise set the angle to the target angle
					else
						lAng[i] = k;
					lgroup[i]->Angle = DegtoRad(lAng[i]);
				}
				else if(lType[i]==3){ //Shield
					//Once again setting offsets to x and y for special cases
					x += lgroup[i]->HitXOffset;
					y += lgroup[i]->HitYOffset;
					if(lMisc1[i]>0){ //If the shield has block flags, run the block weapons function
						if(lFlags[i]&MIF_PIERCE)
							MooshItem_BlockWeapons(vars, lgroup[i], i, false);
						else
							MooshItem_BlockWeapons(vars, lgroup[i], i, true);
					}
				}
				else if(lType[i]==4){ //Wall bounce
					//Turn angle into vX and vY components
					int vX = VectorX(10, lAng[i]);
					int vY = VectorY(10, lAng[i]);
					o = Max(lgroup[i]->Step/100, 1);
					bool bounce = false;
					//Flip if they hit a wall
					if((vX<0&&!MooshItem_CanWalk(lgroup[i], DIR_LEFT, o)) || (vX>0&&!MooshItem_CanWalk(lgroup[i], DIR_RIGHT, o))){
						vX = -vX;
						
						bounce = true;
					}
					if((vY<0&&!MooshItem_CanWalk(lgroup[i], DIR_UP, o)) || (vY>0&&!MooshItem_CanWalk(lgroup[i], DIR_DOWN, o))){
						vY = -vY;
						
						bounce = true;
					}
					//If a wall was hit, update the angle
					if(bounce){
						Game->PlaySound(SFX_MOOSHITEM_WALLBOUNCE);
						lAng[i] = Angle(0, 0, vX, vY);
						lgroup[i]->Angle = DegtoRad(lAng[i]);
						lMisc1[i]--;
						if(lMisc1[i]<=0){
							lgroup[i]->DeadState = 0;
							lFlags[i] &= ~MIF_PIERCE; //Pierce messes with killing weapons here so we take it away when a weapon should be killed
						}
					}
				}
				int tile = lgroup[i]->Tile;
				//OH BOY OH BOY BEAM WEAPONS
				//We have a special way of handling these. Because ZC is so intent on drawing the beam shards, I had to clear the weapon's sprite completely.
				//Then we redraw what it should be with scripts.
				if(lgroup[i]->ID==LW_BEAM){
					//Detect any uncleared beams.
					if(lgroup[i]->OriginalTile!=TIL_INVISIBLE){
						lACounter[i] = 0;
						lgroup[i]->OriginalTile = TIL_INVISIBLE;
						lgroup[i]->Tile = lgroup[i]->OriginalTile;
						lgroup[i]->NumFrames = 0;
						lgroup[i]->ASpeed = 0;
					}
					else{
						lACounter[i] = (lACounter[i]+1)%(lNumFrames[i]*lASpeed[i]);
						tile = lTile[i]+Clamp(Floor(lACounter[i]/lASpeed[i]), 0, lNumFrames[i]-1)*lgroup[i]->TileWidth;
					}
					//When the beam shards happen, kill the weapon early so drawing doesn't bug out
					if(lgroup[i]->DeadState>0)
						lgroup[i]->DeadState = 0;
				}
				//These weapons have special collision exceptions because they can cause friendly fire damage
				else if(lgroup[i]->ID==LW_FIRE||lgroup[i]->ID==LW_REFBEAM||lgroup[i]->ID==LW_REFMAGIC||lgroup[i]->ID==LW_REFROCK){
					if(MooshItem_LinkCollisionNoZ(lgroup[i]))
						lgroup[i]->CollDetection = false;
					else
						lgroup[i]->CollDetection = true;
				}
				int frames = Max(1, lNumFrames[i]);
				//These all handle redrawing of beam animations and setting the directions of other weapon types based on angle so they animate correctly.
				if(lFlags[i]&MIF_4WAY){ //4 way animations
					dir = AngleDir4(WrapDegrees(lAng[i]));
					if(lType[i]!=3)
						lgroup[i]->Dir = dir;
					j = (lgroup[i]->Tile-lTile[i])%frames;
					if(lgroup[i]->ID!=LW_BEAM&&lgroup[i]->OriginalTile!=lTile[i]+frames*dir){
						lgroup[i]->OriginalTile = lTile[i]+frames*dir;
						lgroup[i]->Tile = lgroup[i]->OriginalTile+j;
					}
					if(lgroup[i]->ID==LW_BEAM&&lgroup[i]->DeadState==WDS_ALIVE){
						tile += frames*dir;
						if(Link->HP>0){
							if(lFlags[i]&MIF_2X2)
								Screen->DrawTile(2, x, y-2-lgroup[i]->Z, tile, 2, 2, lgroup[i]->CSet, -1, -1, 0, 0, 0, 0, true, 128);
							else 
								Screen->FastTile(2, x, y-2-lgroup[i]->Z, tile, lgroup[i]->CSet, 128);
						}
					}
				}
				else if(lFlags[i]&MIF_8WAY){ //8 way animations
					dir = AngleDir8(WrapDegrees(lAng[i]));
					if(lType[i]!=3)
						lgroup[i]->Dir = AngleDir4(WrapDegrees(lAng[i]));
					j = (lgroup[i]->Tile-lTile[i])%frames;
					if(lgroup[i]->ID!=LW_BEAM&&lgroup[i]->OriginalTile!=lTile[i]+frames*dir){
						lgroup[i]->OriginalTile = lTile[i]+frames*dir;
						lgroup[i]->Tile = lgroup[i]->OriginalTile+j;
					}
					if(lgroup[i]->ID==LW_BEAM&&lgroup[i]->DeadState==WDS_ALIVE){
						tile += frames*dir;
						if(Link->HP>0){
							if(lFlags[i]&MIF_2X2)
								Screen->DrawTile(2, x, y-2-lgroup[i]->Z, tile, 2, 2, lgroup[i]->CSet, -1, -1, 0, 0, 0, 0, true, 128);
							else
								Screen->FastTile(2, x, y-2-lgroup[i]->Z, tile, lgroup[i]->CSet, 128);
						}
					}
				}
				else if(lFlags[i]&MIF_360WAY){ //360 degree animations
					lgroup[i]->DrawYOffset = -1000;
					if(lType[i]!=3)
						lgroup[i]->Dir = AngleDir4(WrapDegrees(lAng[i]));
						
					if(Link->HP>0){
						if(lFlags[i]&MIF_2X2)
							DrawTile(2, x, y-2-lgroup[i]->Z, tile, 2, 2, lgroup[i]->CSet, -1, -1, x, y-2-lgroup[i]->Z, lAng[i], 0, true, 128);
						else
							DrawTile(2, x, y-2-lgroup[i]->Z, tile, 1, 1, lgroup[i]->CSet, -1, -1, x, y-2-lgroup[i]->Z, lAng[i], 0, true, 128);
					}
				}
				else{ //Static animations
					if(lgroup[i]->ID==LW_BEAM&&lgroup[i]->DeadState==WDS_ALIVE){
						if(Link->HP>0){
							if(lFlags[i]&MIF_2X2)
								DrawTile(2, x, y-2-lgroup[i]->Z, tile, 2, 2, lgroup[i]->CSet, -1, -1, 0, 0, 0, 0, true, 128);
							else
								DrawTile(2, x, y-2-lgroup[i]->Z, tile, 1, 1, lgroup[i]->CSet, -1, -1, 0, 0, 0, 0, true, 128);
						}
					}
				}
				
				//Keep track of the weapon's position so we know where to put death effects when it dies
				lLastX[i] = x;
				lLastY[i] = y;
				
				if(lFlags[i]&MIF_PIERCE){
					lgroup[i]->DeadState = -1;
					lgroup[i]->Dir = -1;
					//Pierce is weird and lets weapons go way offscreen but only when the planets are aligned just right.
					//When I tried to reproduce this in another part of the script, it said "No!"
					if(lgroup[i]->X<-80||lgroup[i]->X>256+64||lgroup[i]->Y<-80||lgroup[i]->Y>176+64)
						lgroup[i]->DeadState = 0;
				}
				
				//This handles the creation of bomb explosions on replacement explosion weapons
				if(vars[12]>0){
					lgroup[i]->CollDetection = false;
					if(lTimer[i]%30==0){
						if(vars[12]==1){
							lweapon boom = CreateLWeaponAt(LW_BOMBBLAST, x+Rand(-8*lgroup[i]->TileWidth, 8*lgroup[i]->TileWidth), y+Rand(-8*lgroup[i]->TileWidth, 8*lgroup[i]->TileWidth));
							boom->Damage = lgroup[i]->Damage;
						}
						else if(vars[12]==2){
							lweapon boom = CreateLWeaponAt(LW_SBOMBBLAST, x+Rand(-8*lgroup[i]->TileWidth, 8*lgroup[i]->TileWidth), y+Rand(-8*lgroup[i]->TileWidth, 8*lgroup[i]->TileWidth));
							boom->Damage = lgroup[i]->Damage;
						}
					}
				}
				
				//Death timer for weapons
				if(lDecay[i]>0){
					lDecay[i]--;
					if(lDecay[i]==0)
						lgroup[i]->DeadState = 0;
				}
			
			}
			//Otherwise we remove it
			else{
				//Here's also where we put special weapon death effects
				if(lFlags[i]&MIF_EXPLODEDEATH){
					lweapon boom = CreateLWeaponAt(LW_BOMBBLAST, lLastX[i], lLastY[i]);
					boom->Damage = vars[15];
					boom->Dir = AngleDir4(WrapDegrees(lAng[i]));
					lFlags[i] &= ~MIF_EXPLODEDEATH;
				}
				//Circular shield weapons shouldn't be cleared in order to prevent an animation error.
				//The way I scripted the behavior is bad and I should feel bad.
				if(vars[16]==0)
					MooshItem_RemLWeapon(vars, lgroup, i);
			}
		}
	}
	int MooshItem_AddLWeapon(int vars, lweapon lgroup, lweapon l, int type, int angle, int flags){
		int lTimer = vars[1];
		int lTile = vars[2];
		int lAng = vars[3];
		int lType = vars[4];
		int lMisc1 = vars[5];
		int lMisc2 = vars[6];
		int lDecay = vars[7];
		int lFlags = vars[8];
		int lACounter = vars[9];
		int lNumFrames = vars[10];
		int lASpeed = vars[11];
		int lLastX = vars[13];
		int lLastY = vars[14];
		
		//All weapons are added at the end of the active part of the array
		lgroup[vars[0]] = l;
		lTimer[vars[0]] = 0;
		lTile[vars[0]] = l->OriginalTile;
		lAng[vars[0]] = angle;
		lType[vars[0]] = type;
		lMisc1[vars[0]] = 0;
		lMisc2[vars[0]] = 0;
		lDecay[vars[0]] = 0;
		lFlags[vars[0]] = flags;
		lACounter[vars[0]] = 0;
		lNumFrames[vars[0]] = Max(l->NumFrames, 1);
		lASpeed[vars[0]] = Max(l->ASpeed, 1);
		lLastX[vars[0]] = l->X;
		lLastY[vars[0]] = l->Y;
		
		//Grow the "size" of the "array" to accomodate
		vars[0]++;
		//But the return value is what it used to be
		return vars[0]-1;
	}
	void MooshItem_RemLWeapon(int vars, lweapon lgroup, int i){
		int lTimer = vars[1];
		int lTile = vars[2];
		int lAng = vars[3];
		int lType = vars[4];
		int lMisc1 = vars[5];
		int lMisc2 = vars[6];
		int lDecay = vars[7];
		int lFlags = vars[8];
		int lACounter = vars[9];
		int lNumFrames = vars[10];
		int lASpeed = vars[11];
		int lLastX = vars[13];
		int lLastY = vars[14];
		
		//Whenever a weapon is removed, the weapon at the end of the array gets copied over to it.
		//It's then marked as free space for a new weapon to be created over.
		vars[0]--;
		lgroup[i] = lgroup[vars[0]];
		lTimer[i] = lTimer[vars[0]];
		lTile[i] = lTile[vars[0]];
		lAng[i] = lAng[vars[0]];
		lType[i] = lType[vars[0]];
		lMisc1[i] = lMisc1[vars[0]];
		lMisc2[i] = lMisc2[vars[0]];
		lDecay[i] = lDecay[vars[0]];
		lFlags[i] = lFlags[vars[0]];
		lACounter[i] = lACounter[vars[0]];
		lNumFrames[i] = lNumFrames[vars[0]];
		lASpeed[i] = lASpeed[vars[0]];
		lLastX[i] = lLastX[vars[0]];
		lLastY[i] = lLastY[vars[0]];
	}
	int MooshItem_Homing_TargetAngle(int vars, int angle, lweapon l){
		int minDist = 1000;
		npc min;
		for(int i=Screen->NumNPCs(); i>=1; i--){
			npc n = Screen->LoadNPC(i);
			//If the enemy isn't flagged as beatable, don't target it
			if(n->MiscFlags&(1<<3))
				continue;
			if(!n->CollDetection)
				continue;
			//Get potential value for the enemy (based on how much it resists damage)
			float potential = MooshItem_CanHurt(l, n);
			if(potential==0)
				continue;
			//A combination of the distance to the enemy and the damage potential determines which the script will target
			if(Distance(CenterX(l), CenterY(l), CenterX(n), CenterY(n))-10*potential<minDist){
				minDist = Distance(CenterX(l), CenterY(l), CenterX(n), CenterY(n))-10*potential;
				min = n;
			}
		}
		//If a valid target was found, return the angle to it
		if(min->isValid())
			return Angle(CenterX(l), CenterY(l), CenterX(min), CenterY(min));
		//Otherwise return the last angle
		return angle;
	}
	int MooshItem_BlockWeapons(int vars, lweapon l, int i, bool remOnCollision){
		bool hit;
		//Cycle through all eweapons
		for(int j=Screen->NumEWeapons(); j>=1; j--){
			eweapon e = Screen->LoadEWeapon(j);
			//Remove the ones that collide with the lweapon and can be destroyed
			if(Collision(e, l)){
				if(MooshItem_CanBlockEWeapon(vars, i, e)){
					Game->PlaySound(SFX_MOOSHITEM_BLOCK);
					e->DeadState = 0;
					hit = true;
				}
			}
		}
		//Only kill the lweapon once its cycled through all weapons to prevent weapon priority BS with multiple collisions
		if(remOnCollision&&hit)
			l->DeadState = 0;
	}
	bool MooshItem_CanBlockEWeapon(int vars, int i, eweapon e){
		int lMisc1 = vars[5];
		//This is pretty much just imitating shield block flags
		if(e->ID==EW_ROCK){
			if(lMisc1[i]&1)
				return true;
		}
		else if(e->ID==EW_ARROW){
			if(lMisc1[i]&2)
				return true;
		}
		else if(e->ID==EW_BRANG){
			if(lMisc1[i]&4)
				return true;
		}
		else if(e->ID==EW_FIREBALL){
			if(lMisc1[i]&8)
				return true;
		}
		else if(e->ID==EW_BEAM){
			if(lMisc1[i]&16)
				return true;
		}
		else if(e->ID==EW_MAGIC){
			if(lMisc1[i]&32)
				return true;
		}
		else if(e->ID==EW_FIRE||e->ID==EW_FIRE2){
			if(lMisc1[i]&64)
				return true;
		}
		else if(e->ID<=EW_SCRIPT10){
			if(lMisc1[i]&128)
				return true;
		}
		else if(e->ID==EW_FIREBALL2){
			if(lMisc1[i]&256)
				return true;
		}
		//But there's an extra flag for bombs and supers
		else if(e->ID==EW_BOMB||e->ID==EW_SBOMB){
			if(lMisc1[i]&512)
				return true;
		}
		return false;
	}
	float MooshItem_CanHurt(lweapon l, npc n){
		int type = l->ID;
		int def;
		//This is imitating enemy editor defenses
		if(type>=LW_SCRIPT1)
			def = n->Defense[NPCD_SCRIPT];
		else if(type==LW_BRANG)
			def = n->Defense[NPCD_BRANG];
		else if(type==LW_BOMBBLAST)
			def = n->Defense[NPCD_BOMB];
		else if(type==LW_SBOMBBLAST)
			def = n->Defense[NPCD_SBOMB];
		else if(type==LW_ARROW)
			def = n->Defense[NPCD_ARROW];
		else if(type==LW_FIRE)
			def = n->Defense[NPCD_FIRE];
		else if(type==LW_MAGIC)
			def = n->Defense[NPCD_MAGIC];
		else if(type==LW_BEAM)
			def = n->Defense[NPCD_BEAM];
		else if(type==LW_REFBEAM)
			def = n->Defense[NPCD_REFBEAM];
		else if(type==LW_REFMAGIC)
			def = n->Defense[NPCD_REFMAGIC];
		else if(type==LW_REFROCK)
			def = n->Defense[NPCD_REFROCK];
		
		//But the return value is treated as the enemy's damage potential.
		//This should make the script priotitize enemies that it will deal more damage to.
		if(def==NPCDT_BLOCK||def==NPCDT_IGNORE)
			return 0;
		if(def==NPCDT_ONEHITKILL)
			return 10;
		if(def>=NPCDT_BLOCK1&&def<=NPCDT_BLOCK8||def==NPCDT_IGNORE1){
			if(def==NPCDT_BLOCK8&&l->Damage>=16)
				return 1;
			else if(def==NPCDT_BLOCK6&&l->Damage>=12)
				return 1;
			else if(def==NPCDT_BLOCK4&&l->Damage>=8)
				return 1;
			else if(def==NPCDT_BLOCK2&&l->Damage>=4)
				return 1;
			else if(l->Damage>=2)
				return 1;
			return 0;
		}
		if(def==NPCDT_HALFDAMAGE)
			return 0.5;
		else if(def==NPCDT_QUARTERDAMAGE)
			return 0.25;
		return 1;
	}
	bool MooshItem_CanTakeResource(int ID, int mpCost){
		if(mpCost==0)
			return true;
		itemdata itemdat = Game->LoadItemData(ID);
		if(itemdat->Counter>-1){ //If a counter is set
			if(itemdat->Counter==CR_LIFE){ //If the counter is health, don't allow it to hit 0
				if(Game->Counter[itemdat->Counter]<=mpCost)
					return false;
			}
			else if(Game->Counter[itemdat->Counter]<mpCost)
				return false;
		}
		else{ //Otherwise it's a regular magic cost
			//Only magic costs are affected by 1/2 magic
			mpCost = mpCost*Game->Generic[GEN_MAGICDRAINRATE];
			if(Link->MP<mpCost)
				return false;
		}
		return true;
	}
	void MooshItem_TakeResource(int ID, int mpCost){
		if(mpCost==0)
			return;
		itemdata itemdat = Game->LoadItemData(ID);
		if(itemdat->Counter>-1){ //If a counter is set
			if(itemdat->Counter==CR_LIFE){ //If the counter is health, don't allow it to hit 0
				if(Game->Counter[itemdat->Counter]>mpCost){
					Game->Counter[itemdat->Counter] -= mpCost;
					Game->PlaySound(SFX_MOOSHITEM_HP_COST);
					if(Link->Action==LA_NONE||Link->Action==LA_WALKING||Link->Action==LA_ATTACKING||Link->Action==LA_GOTHURTLAND)
						Link->Action = LA_GOTHURTLAND;
					else if(Link->Action==LA_SWIMMING||Link->Action==LA_GOTHURTWATER)
						Link->Action = LA_GOTHURTWATER;
					Link->HitDir = -1;
				}
			}
			else if(Game->Counter[itemdat->Counter]>=mpCost)
				Game->Counter[itemdat->Counter] -= mpCost;
		}
		else{ //Otherwise it's a regular magic cost
			//Only magic costs are affected by 1/2 magic
			mpCost = mpCost*Game->Generic[GEN_MAGICDRAINRATE];
			if(Link->MP>=mpCost)
				Link->MP -= mpCost;
		}
	}
	int MooshItem_8WayAimAngle(int angle){
		int xAxis;
		int yAxis;
		//Convert Link's directional inputs into axes so opposite inputs cancel out
		if(Link->InputLeft&&!Link->InputRight)
			xAxis = -1;
		else if(!Link->InputLeft&&Link->InputRight)
			xAxis = 1;
		if(Link->InputUp&&!Link->InputDown)
			yAxis = -1;
		else if(!Link->InputUp&&Link->InputDown)
			yAxis = 1;
		
		//If he's holding a cardinal diretcion face that way
		if(yAxis==-1&&xAxis==0)
			Link->Dir=DIR_UP;
		else if(yAxis==1&&xAxis==0)
			Link->Dir=DIR_DOWN;
		else if(xAxis==-1&&yAxis==0)
			Link->Dir=DIR_LEFT;
		else if(xAxis==1&&yAxis==0)
			Link->Dir=DIR_RIGHT;
		
		//But if he's holding the opposite of the direction he's facing, turn him around
		if(Link->Dir==DIR_UP&&yAxis==1)
			Link->Dir=DIR_DOWN;
		else if(Link->Dir==DIR_UP&&yAxis==-1)
			Link->Dir=DIR_UP;
		else if(Link->Dir==DIR_LEFT&&xAxis==1)
			Link->Dir=DIR_RIGHT;
		else if(Link->Dir==DIR_RIGHT&&xAxis==-1)
			Link->Dir=DIR_LEFT;
		
		//Left up
		if(xAxis==-1&&yAxis==-1)
			return -135;
		//Right up
		else if(xAxis==1&&yAxis==-1)
			return -45;
		//Left down
		else if(xAxis==-1&&yAxis==1)
			return 135;
		//Right down
		else if(xAxis==1&&yAxis==1)
			return 45;
		//Up
		else if(yAxis==-1)
			return -90;
		//Down
		else if(yAxis==1)
			return 90;
		//Left
		else if(xAxis==-1)
			return 180;
		//Right
		else if(xAxis==1)
			return 0;
		return angle;
	}
	bool MooshItem_CanWalk(lweapon l, int dir, int step){
		int x; int y;
		//Returns whether a square weapon can move in a direction
		for(int i=0; i<=l->HitWidth-1; i=Min(i+8, l->HitWidth-1)){
			if(dir==DIR_UP){
				x = l->X+l->HitXOffset+i;
				y = l->Y+l->HitYOffset-step;
			}
			else if(dir==DIR_DOWN){
				x = l->X+l->HitXOffset+i;
				y = l->Y+l->HitYOffset+l->HitHeight-1+step;
			}
			else if(dir==DIR_LEFT){
				x = l->X+l->HitXOffset-step;
				y = l->Y+l->HitYOffset+i;
			}
			else if(dir==DIR_RIGHT){
				x = l->X+l->HitXOffset+l->HitWidth-1+step;
				y = l->Y+l->HitYOffset+i;
			}
			if(Screen->isSolid(x, y)){
				//Account for combo types that are solid but aren't "solid"
				int cd = Screen->ComboD[ComboAt(x, y)];
				if(cd!=CT_WATER&&cd!=CT_SWIMWARP&&cd!=CT_SWIMWARPB&&cd!=CT_SWIMWARPC&&cd!=CT_SWIMWARPD&&
					cd!=CT_DIVEWARP&&cd!=CT_DIVEWARPB&&cd!=CT_DIVEWARPC&&cd!=CT_DIVEWARPD&&
					cd!=CT_LADDERONLY&&cd!=CT_LADDERHOOKSHOT&&cd!=CT_HOOKSHOTONLY)
				return false;
			}
			//Return when the end of the collision line is reached
			if(i==l->HitWidth-1)
				return true;
		}
		return true;
	}
	//Duplicate of LinkCollision that doesn't account for Z-axis
	//This prevents Link jumping onto fire/reflected weapons and hurting himself
	bool MooshItem_LinkCollisionNoZ(lweapon b) {
	  int ax = Link->X + Link->HitXOffset;
	  int bx = b->X + b->HitXOffset;
	  int ay = Link->Y + Link->HitYOffset;
	  int by = b->Y + b->HitYOffset;
	  return RectCollision(ax, ay, ax+Link->HitWidth, ay+Link->HitHeight, bx, by, bx+b->HitWidth, by+b->HitHeight);
	}
}

//This FFC script handles the sword animations
ffc script MooshItem_Animations{
	void run(int animType, int ID_mpCost, int type_step, int wType_maxShot, int arg1_arg2, int arg3_arg4, int sprite_sfx, int flags){
		int i; int j; int k;
		lweapon melee; 
		int meleeSprite = MooshItem_LeftArg(sprite_sfx)+1;
		int ID = MooshItem_LeftArg(ID_mpCost);
		itemdata itemdat = Game->LoadItemData(ID);
		int damage = itemdat->Power*2;
		int startTile;
		melee = CreateLWeaponAt(LW_MOOSHITEM_MELEE, -48, -48);
		melee->UseSprite(meleeSprite);
		startTile = melee->OriginalTile;
		melee->DeadState = 0;
		
		int args[8];
		
		args[0] = ID_mpCost;
		args[1] = type_step;
		args[2] = wType_maxShot;
		args[3] = arg1_arg2;
		args[4] = arg3_arg4;
		args[5] = sprite_sfx;
		args[6] = flags;
		
		int handler[] = "MooshItem_Handler";		
		
		//These are all reproductions of the slash animations in ZC as measured with a script
		//Some minor details like the little step forward Link takes aren't included
		if(animType==0){ //Stab
			Game->PlaySound(SFX_MOOSHITEM_MELEE);
			for(i=0; i<10; i++){
				if(Link->Dir==DIR_UP){
					if(i<8)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -1, -10, DIR_UP, damage);
					else if(i<9)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -1, -6, DIR_UP, damage);
					else	
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -1, -2, DIR_UP, damage);
				}
				else if(Link->Dir==DIR_DOWN){
					if(i<8)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 1, 13, DIR_DOWN, damage);
					else if(i<9)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 1, 9, DIR_DOWN, damage);
					else	
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 1, 5, DIR_DOWN, damage);
				}
				else if(Link->Dir==DIR_LEFT){
					if(i<8)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -11, 3, DIR_LEFT, damage);
					else if(i<9)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -7, 3, DIR_LEFT, damage);
					else	
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -3, 3, DIR_LEFT, damage);
				}
				else if(Link->Dir==DIR_RIGHT){
					if(i<8)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 11, 3, DIR_RIGHT, damage);
					else if(i<9)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 7, 3, DIR_RIGHT, damage);
					else	
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 3, 3, DIR_RIGHT, damage);
				}
				Link->Action = LA_NONE;
				Link->Action = LA_ATTACKING;
				if(i==8)
					RunFFCScript(Game->GetFFCScript(handler), args);
				if(melee->isValid())
					melee->Dir = Link->Dir;
				Waitframe();
			}
		}
		else if(animType==1){ //Slash
			Game->PlaySound(SFX_MOOSHITEM_MELEE);
			for(i=0; i<14; i++){
				if(Link->Dir==DIR_UP){
					if(i<6)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 15, -1, DIR_RIGHT, damage);
					else if(i<10)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 12, -10, DIR_RIGHTUP, damage);
					else if(i<13)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -1, -15, DIR_UP, damage);
					else
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -1, -10, DIR_UP, damage);
				}
				else if(Link->Dir==DIR_DOWN){
					if(i<6)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -13, 1, DIR_LEFT, damage);
					else if(i<10)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -11, 16, DIR_LEFTDOWN, damage);
					else if(i<13)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 1, 18, DIR_DOWN, damage);
					else
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 1, 13, DIR_DOWN, damage);
				}
				else if(Link->Dir==DIR_LEFT){
					if(i<6)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 3, -13, DIR_UP, damage);
					else if(i<10)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -12, -10, DIR_LEFTUP, damage);
					else if(i<13)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -18, 3, DIR_LEFT, damage);
					else
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -11, 3, DIR_LEFT, damage);
				}
				else if(Link->Dir==DIR_RIGHT){
					if(i<6)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 3, -13, DIR_UP, damage);
					else if(i<10)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 18, -10, DIR_RIGHTUP, damage);
					else if(i<13)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 18, 3, DIR_RIGHT, damage);
					else
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 11, 3, DIR_RIGHT, damage);
				}
				if(i<10){
					Link->Action = LA_NONE;
					Link->Action = LA_ATTACKING;
				}
				if(i==10)
					RunFFCScript(Game->GetFFCScript(handler), args);
				if(melee->isValid())
					melee->Dir = Link->Dir;
				Waitframe();
			}
		}
		else if(animType==2){ //Z3 Slash
			Game->PlaySound(SFX_MOOSHITEM_MELEE);
			for(i=0; i<14; i++){
				if(Link->Dir==DIR_UP){
					if(i<6)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 18, -10, DIR_RIGHTUP, damage);
					else if(i<10)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -1, -15, DIR_UP, damage);
					else if(i<13)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -12, -10, DIR_LEFTUP, damage);
					else
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -5, -5, DIR_LEFTUP, damage);
				}
				else if(Link->Dir==DIR_DOWN){
					if(i<6)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -11, 16, DIR_LEFTDOWN, damage);
					else if(i<10)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 1, 18, DIR_DOWN, damage);
					else if(i<13)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 15, 13, DIR_RIGHTDOWN, damage);
					else
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 8, 8, DIR_RIGHTDOWN, damage);
				}
				else if(Link->Dir==DIR_LEFT){
					if(i<6)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -12, -10, DIR_LEFTUP, damage);
					else if(i<10)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -18, 3, DIR_LEFT, damage);
					else if(i<13)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -11, 16, DIR_LEFTDOWN, damage);
					else
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, -4, 11, DIR_LEFTDOWN, damage);
				}
				else if(Link->Dir==DIR_RIGHT){
					if(i<6)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 18, -10, DIR_RIGHTUP, damage);
					else if(i<10)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 18, 3, DIR_RIGHT, damage);
					else if(i<13)
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 15, 13, DIR_RIGHTDOWN, damage);
					else
						melee = MooshItem_UpdateMeleeAnim(melee, meleeSprite, startTile, 8, 8, DIR_RIGHTDOWN, damage);
				}
				if(i<10){
					Link->Action = LA_NONE;
					Link->Action = LA_ATTACKING;
				}
				if(i==10)
					RunFFCScript(Game->GetFFCScript(handler), args);
				if(melee->isValid())
					melee->Dir = Link->Dir;
				Waitframe();
			}
		}
		if(melee->isValid())
			melee->DeadState = 0;
	}
	lweapon MooshItem_UpdateMeleeAnim(lweapon melee, int sprite, int startTile, int x, int y, int dir, int damage){
		//This updates the melee lweapon and ensures that one always exists
		if(melee->isValid()){
			melee->X = Link->X+x;
			melee->Y = Link->Y+y;
			melee->Z = Link->Z;
		}
		else{
			melee = CreateLWeaponAt(LW_MOOSHITEM_MELEE, Link->X+x, Link->Y+y);
			melee->Z = Link->Z;
			melee->UseSprite(sprite);
			melee->Step = 0;
			melee->Damage = damage;
		}
		//Change the tile  based on the current direction
		int frames = Max(melee->NumFrames, 1);
		melee->OriginalTile = startTile+frames*dir;
		melee->Tile = melee->OriginalTile+((melee->Tile-melee->OriginalTile)%frames);
		return melee;
	}
}

//NOTE: To set shave offsets, set the enemy's Attribute 5 to (ShaveX+ShaveY*16)
ffc script EZBoss{
	void run(int enemyid){
		int i; int j; int k; int m; int angle; int dist; int x; int y;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		npc summons[256];
		npc enem;
		eweapon e;
		
		int barrierShift[312];
		
		for(i=0; i<12; i++){
			barrierShift[300+i] = ghost->Attributes[i];
		}
		int movementStyle = barrierShift[300];
		int attack1 = barrierShift[301];
		int attack2 = barrierShift[302];
		int attack3 = barrierShift[303];
                int shaveHitbox = barrierShift[304];
		int special = barrierShift[305];
		int size = barrierShift[306];
		int fireSFX = barrierShift[307];
		int fireSPR = barrierShift[308];
		int flags = barrierShift[309];
		
		int constantAttack;
		int doConstantAttack;
		
		//Certain attacks in Attack 1 do a constant attack instead
		//This is triggered at certain parts of the enemy's walk pattern
		if(attack1==44)
			constantAttack = 44;
		else if(attack1==45)
			constantAttack = 45;
		else if(attack1==46)
			constantAttack = 46;
		else if(attack1==47)
			constantAttack = 47;
		else if(attack1==48)
			constantAttack = 48;
		
		if(attack1==50||attack1==51){
			EZB_Barriershift_Store(ghost, special, barrierShift);
			if(attack1==51)
				barrierShift[200] = 2;
		}
		
		//If there's a constant attack, shift all other attacks down
		if(constantAttack>0||barrierShift[200]){
			attack1 = attack2;
			attack2 = attack3;
			attack3 = 0;
		}
		
        int shaveX = shaveHitbox&1111b;
        int shaveY = Floor(shaveHitbox>>4)&1111b;
		
		//An enemy with no collision uses stun to turn it off and so cannot be stunned normally
		if(!(flags&EZBF_NOCOLL)&&!(flags&EZBF_NOSTUN)){
			Ghost_SetFlag(GHF_STUN);
			Ghost_SetFlag(GHF_CLOCK);
		}
		
		int w = size&1111b;
		int h = (size>>4)&1111b;
		if(h==0)
			h = w;
		w = Clamp(w, 1, 4);
		h = Clamp(h, 1, 4);
		
		barrierShift[310] = ghost->Attributes[10];
		int combo = barrierShift[310];
		Ghost_Transform(this, ghost, -1, -1, w, h);
		Ghost_SetHitOffsets(ghost, shaveY, shaveY, shaveX, shaveX);
		
		if(flags&EZBF_8WAY)
			Ghost_SetFlag(GHF_8WAY);
		else if(flags&EZBF_4WAY)
			Ghost_SetFlag(GHF_4WAY);
		if(flags&EZBF_NOFALL)
			Ghost_SetFlag(GHF_NO_FALL);
		if(flags&EZBF_FLYING){
			Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
			Ghost_SetFlag(GHF_FLYING_ENEMY);
			this->Flags[FFCF_OVERLAY] = true;
			if(EZB_FLYING_ZPOS&&(flags&EZBF_NOFALL)&&!IsSideview()){
				Ghost_SetFlag(GHF_FAKE_Z);
				Ghost_Z = 8;
			}
		}
		else if(flags&EZBF_AQUATIC){
			Ghost_SetFlag(GHF_WATER_ONLY);
		}
		if(flags&EZBF_KNOCKBACK){
			Ghost_SetFlag(GHF_KNOCKBACK);
		}
		if(EZB_ALWAYS_FAKE_Z)
			Ghost_SetFlag(GHF_FAKE_Z);
		
		int stepCounter = -1;
		int attackCooldown = ghost->Haltrate*10;
		int stepAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
		int stepCooldown = ghost->Rate;
		int vX; int vY;
		int lastAttack = -1;
		
		if(movementStyle==4){
			angle = Rand(360);
			vX = VectorX(ghost->Step/100, angle);
			vY = VectorY(ghost->Step/100, angle);
		}
		if(movementStyle==11){
			stepAngle = Rand(4);
		}
		
		while(true){
			bool attackCond = false;
			//Handle Movement
			if(movementStyle==0){ //4 Way Halting Walk
				stepCounter = Ghost_HaltingWalk4(stepCounter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger, ghost->Haltrate, 48);
				if(stepCounter==16)
					attackCond = true;
			}
			else if(movementStyle==1){ //4 Way Constant Walk
				stepCounter = Ghost_ConstantWalk4(stepCounter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger);
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==2){ //8 Way Constant Walk
				stepCounter = Ghost_ConstantWalk8(stepCounter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger);
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==3){ //Homing in on Link
				if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>8){
					EZB_FaceLink(this, ghost, barrierShift);
					Ghost_MoveAtAngle(Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), ghost->Step/100, 0);
				}
				if(ghost->Homing>0&&Link->Action==LA_ATTACKING&&Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())<ghost->Homing){
					if(attackCooldown<ghost->Haltrate*5)
						attackCond = true;
				}
				
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==4){ //Wall Bounce
				Ghost_MoveXY(vX, vY, 0);
				if((vX<0&&!Ghost_CanMove(DIR_LEFT, 1, 0)) || (vX>0&&!Ghost_CanMove(DIR_RIGHT, 1, 0))){
					vX = -vX;
					doConstantAttack = 1;
				}
				if((vY<0&&!Ghost_CanMove(DIR_UP, 1, 0)) || (vY>0&&!Ghost_CanMove(DIR_DOWN, 1, 0))){
					vY = -vY;
					if(doConstantAttack==0)
						doConstantAttack = 1;
				}
					
				Ghost_Dir = EZB_AngleDir(this, ghost, barrierShift, Angle(0, 0, vX*10, vY*10));
				if(flags&EZBF_FACELINK)
					EZB_FaceLink(this, ghost, barrierShift);
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==5){ //Periodic Reaim
				Ghost_MoveAtAngle(stepAngle, ghost->Step/100, 0);
				Ghost_Dir = EZB_AngleDir(this, ghost, barrierShift, stepAngle);
				if(flags&EZBF_FACELINK)
					EZB_FaceLink(this, ghost, barrierShift);
					
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
					
				stepCounter++;
				if(stepCounter>80&&Rand(10)==0){
					stepAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					stepCounter = 0;
					if(doConstantAttack==0)
						doConstantAttack = 1;
				}
			}
			else if(movementStyle==6){ //Lazy chase
				float homing = ghost->Homing*0.001;
				float topSpeed = ghost->Step*0.01;
				vX = Clamp(vX+Sign(CenterLinkX()-CenterX(ghost))*homing, -topSpeed, topSpeed);
				vY = Clamp(vY+Sign(CenterLinkY()-CenterY(ghost))*homing, -topSpeed, topSpeed);
				Ghost_MoveXY(vX, vY, 0);
				if((vX<0&&!Ghost_CanMove(DIR_LEFT, 1, 0)) || (vX>0&&!Ghost_CanMove(DIR_RIGHT, 1, 0))){
					vX = -vX;
					if(doConstantAttack==0)
						doConstantAttack = 1;
				}
				if((vY<0&&!Ghost_CanMove(DIR_UP, 1, 0)) || (vY>0&&!Ghost_CanMove(DIR_DOWN, 1, 0))){
					vY = -vY;
					if(doConstantAttack==0)
						doConstantAttack = 1;
				}
					
				Ghost_Dir = EZB_AngleDir(this, ghost, barrierShift, Angle(0, 0, vX*10, vY*10));
				if(flags&EZBF_FACELINK)
					EZB_FaceLink(this, ghost, barrierShift);
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==7){ //Hopping
				EZB_Waitframes(this, ghost, barrierShift, ghost->Haltrate*8+Choose(0, 8, 16));
				if(ghost->Homing==0)
					stepAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())+Rand(-30, 30);
				else
					stepAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())+Rand(-ghost->Homing, ghost->Homing);
				Game->PlaySound(SFX_JUMP);
				Ghost_Jump = 2.6;
				while(Ghost_Jump>0||Ghost_Z>0){
					Ghost_Dir = EZB_AngleDir(this, ghost, barrierShift, stepAngle);
					Ghost_MoveAtAngle(stepAngle, ghost->Step/100, 0);
					if(flags&EZBF_FACELINK)
						EZB_FaceLink(this, ghost, barrierShift);
					EZB_Waitframe(this, ghost, barrierShift);
				}
				if(stepCooldown>0)
					stepCooldown--;
				if(stepCooldown<=0||Rand(Max(Ceiling(ghost->Rate*0.5), 2))==0){
					attackCond = true;
					stepCooldown = ghost->Rate;
				}
				if(!attackCond)
					doConstantAttack = 1;
			}
			else if(movementStyle==8){ //Teleport
				EZB_Waitframes(this, ghost, barrierShift, ghost->Haltrate*8+Choose(0, 8, 16));
				EZB_Teleport(this, ghost, barrierShift);
				if(stepCooldown>0)
					stepCooldown--;
				if(stepCooldown<=0||Rand(Max(Ceiling(ghost->Rate*0.5), 2))==0){
					attackCond = true;
					stepCooldown = ghost->Rate;
				}
				if(!attackCond)
					doConstantAttack = 1;
			}
			else if(movementStyle==9){ //Rapid hop
				stepAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())+Rand(-ghost->Haltrate, ghost->Haltrate);
				Game->PlaySound(SFX_JUMP);
				if(ghost->Homing==0)
					Ghost_Jump = 2.6;
				else
					Ghost_Jump = 0.01*ghost->Homing;
				if(ghost->Rate>0){
					k = Ghost_Jump * Clamp(0.01*ghost->Rate, 0, 80);
					Ghost_Jump += Rand(-100, 100)*0.01*k;
				}
				while(Ghost_Jump>0||Ghost_Z>0){
					Ghost_Dir = EZB_AngleDir(this, ghost, barrierShift, stepAngle);
					Ghost_MoveAtAngle(stepAngle, ghost->Step/100, 0);
					if(flags&EZBF_FACELINK)
						EZB_FaceLink(this, ghost, barrierShift);
					
					if(attackCooldown>0)
						attackCooldown--;
					else if(Rand(24)==0)
						attackCond = true;
					
					EZB_Waitframe(this, ghost, barrierShift);
					
					if(attackCond){
						while(Ghost_Z>0){
							Ghost_Dir = EZB_AngleDir(this, ghost, barrierShift, stepAngle);
							Ghost_MoveAtAngle(stepAngle, ghost->Step/100, 0);
							if(flags&EZBF_FACELINK)
								EZB_FaceLink(this, ghost, barrierShift);
							EZB_Waitframe(this, ghost, barrierShift);
						}
					}
				}
				if(!attackCond)
					doConstantAttack = 1;
			}
			else if(movementStyle==10){ //Run away
				if(ghost->Homing==0||Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())<ghost->Homing){
					angle = Angle(CenterLinkX(), CenterLinkY(), CenterX(ghost), CenterY(ghost));
					x = Ghost_X+VectorX(6, angle);
					y = Ghost_Y+VectorY(6, angle);
					if(stepCounter>0&&stepAngle!=-1000){
						stepCounter--;
						EZB_FaceAngle(this, ghost, barrierShift, stepAngle);
						Ghost_MoveAtAngle(stepAngle, ghost->Step/100, 0);
					}
					else if(EZB_CanPlace(this, ghost, x, y)){
						if(stepCounter>0)
							stepCounter--;
						stepAngle = -1000;
						EZB_FaceAngle(this, ghost, barrierShift, angle);
						Ghost_MoveAtAngle(angle, ghost->Step/100, 0);
					}
					else{
						stepAngle = WrapDegrees(angle + Choose(-140, 140));
						stepCounter = Floor(32/(ghost->Step*0.01));
						if(doConstantAttack==0)
							doConstantAttack = 1;
					}
				}
				else if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>ghost->Homing+32){
					EZB_FaceLink(this, ghost, barrierShift);
					Ghost_MoveAtAngle(Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), ghost->Step/100, 0);
				}
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==11){ //Turn at wall
				if(ghost->Homing>0)
					stepAngle = Ghost_Dir;
				if(!Ghost_CanMove(stepAngle, 1, 0)){
					if(ghost->Rate==0){
						if(stepAngle==DIR_UP)
							stepAngle = DIR_RIGHT;
						else if(stepAngle==DIR_DOWN)
							stepAngle = DIR_LEFT;
						else if(stepAngle==DIR_LEFT)
							stepAngle = DIR_UP;
						else if(stepAngle==DIR_RIGHT)
							stepAngle = DIR_DOWN;
					}
					else if(ghost->Rate==1){
						if(stepAngle==DIR_UP)
							stepAngle = DIR_LEFT;
						else if(stepAngle==DIR_DOWN)
							stepAngle = DIR_RIGHT;
						else if(stepAngle==DIR_LEFT)
							stepAngle = DIR_DOWN;
						else if(stepAngle==DIR_RIGHT)
							stepAngle = DIR_UP;
					}
					else if(ghost->Rate==2){
						if(stepAngle==DIR_UP)
							stepAngle = DIR_DOWN;
						else if(stepAngle==DIR_DOWN)
							stepAngle = DIR_UP;
						else if(stepAngle==DIR_LEFT)
							stepAngle = DIR_RIGHT;
						else if(stepAngle==DIR_RIGHT)
							stepAngle = DIR_LEFT;
					}
					else{
						if(stepAngle==DIR_UP)
							stepAngle = Choose(DIR_LEFT, DIR_RIGHT);
						else if(stepAngle==DIR_DOWN)
							stepAngle = Choose(DIR_LEFT, DIR_RIGHT);
						else if(stepAngle==DIR_LEFT)
							stepAngle = Choose(DIR_UP, DIR_DOWN);
						else if(stepAngle==DIR_RIGHT)
							stepAngle = Choose(DIR_UP, DIR_DOWN);
					}
					if(doConstantAttack==0)
						doConstantAttack = 1;
				}
				Ghost_Dir = stepAngle;
				Ghost_Move(Ghost_Dir, ghost->Step/100, 0);
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			
			if(doConstantAttack==1){
				if(constantAttack==44){ //Fireball (Directional)
					EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir), 150);
				}
				else if(constantAttack==45){ //Fireball (Angular)
					EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 150);
				}
				else if(constantAttack==46){ //Summon
					if ( Screen->NumNPCs() < EZB_TOTAL_SUMMON_CAP && EZB_NumSummons(summons) < EZB_SUMMON_CAP ) {
						Game->PlaySound(SFX_EZB_SUMMON);
						enem = CreateNPCAt(special, CenterX(ghost)-8, CenterY(ghost)-8);
						EZB_AddSummon(enem, summons);
					}
				}
				else if(constantAttack==47){ //4 Way (HV)
					for(i=0; i<4; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, 90*i, 150);
					}
				}
				else if(constantAttack==48){ //4 Way (Diag)
					for(i=0; i<4; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, 45+90*i, 150);
					}
				}
				doConstantAttack = -8;
			}
			if(doConstantAttack<0)
				++doConstantAttack;
			
			if(attackCond&&(attack1||barrierShift[200])){
				//Select an attack
				int attack;
				if(attack2==0)
					attack = attack1;
				else if(attack3==0)
					attack = Choose(attack1, attack2);
				else
					attack = Choose(attack1, attack2, attack3);
				
				if(EZB_DONT_REPEAT_LAST_ATTACK&&attack==lastAttack){
					if(attack3==0){
						for(i=0; i<32&&attack==lastAttack; i++)
							attack = Choose(attack1, attack2);
					}
					else{
						for(i=0; i<32&&attack==lastAttack; i++)
							attack = Choose(attack1, attack2, attack3);
					}
				}
				
				if(attack==1){ //Dash
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = 2;
					Ghost_Data = combo;
					Game->PlaySound(SFX_EZB_DASH);
					while(EZB_CanMoveAngle(angle)){
						k = Min(k+0.2, 5);
						Ghost_MoveAtAngle(angle, k, 0);
						EZB_Trail(this, ghost, barrierShift);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==2){ //Shoot (Directional)
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir), 150);
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==3){ //Shoot (Angular)
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 150);
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==4){ //Tri Shot (Directional)
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					for(i=-1; i<=1; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir)+30*i, 250);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==5){ //Tri Shot (Angular)
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					for(i=-1; i<=1; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())+30*i, 250);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==6){ //Stream (Directional)
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = EZB_DirAngle(Ghost_Dir);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					for(i=0; i<10; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 350);
						EZB_Waitframes(this, ghost, barrierShift, 8);
					}
					EZB_Waitframes(this, ghost, barrierShift, 12);
				}
				if(attack==7){ //Stream (Angular)
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					for(i=0; i<10; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 350);
						EZB_Waitframes(this, ghost, barrierShift, 8);
					}
					EZB_Waitframes(this, ghost, barrierShift, 12);
				}
				if(attack==8){ //Breath (Directional)
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = EZB_DirAngle(Ghost_Dir);
					EZB_Waitframes(this, ghost, barrierShift, 24);
					for(i=0; i<24; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+Rand(-10-i, 10+i), 250);
						EZB_Waitframes(this, ghost, barrierShift, 4);
					}
				}
				if(attack==9){ //Breath (Angular)
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 24);
					for(i=0; i<24; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+Rand(-10-i, 10+i), 250);
						EZB_Waitframes(this, ghost, barrierShift, 4);
					}
				}
				if(attack==10){ //Sweep (Directional)
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					k = Choose(-1, 1);
					angle = EZB_DirAngle(Ghost_Dir)-75*k;
					for(i=0; i<7; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 150);
						angle += k*25;
						EZB_Waitframes(this, ghost, barrierShift, 4);
					}
					EZB_Waitframes(this, ghost, barrierShift, 48);
				}
				if(attack==11){ //Sweep (Angular)
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					k = Choose(-1, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())-75*k;
					for(i=0; i<7; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 150);
						angle += k*25;
						EZB_Waitframes(this, ghost, barrierShift, 2);
					}
					EZB_Waitframes(this, ghost, barrierShift, 48);
				}
				if(attack==12){ //Bullet Barrage
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())-45;
					for(i=0; i<3; i++){
						for(j=-4; j<=4; j+=2){
							EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+16*j, 150);
						}
						EZB_Waitframes(this, ghost, barrierShift, 16);
						for(j=-5; j<=5; j+=2){
							EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+16*j, 150);
						}
						EZB_Waitframes(this, ghost, barrierShift, 24);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==13){ //Bullet Swirl
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					k = Choose(-1, 1);
					angle = Rand(360);
					for(i=0; i<15; i++){
						for(j=0; j<5; j++){
							EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+72*j, 150);
						}
						angle += 4*k;
						EZB_Waitframes(this, ghost, barrierShift, 4);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==14){ //Bullet Rings
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					for(i=0; i<3; i++){
						angle = Rand(360);
						for(j=0; j<10; j++){
							EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+360/10*j, 180);
						}
						EZB_Waitframes(this, ghost, barrierShift, 45);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==15){ //Laser
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(i=0; i<30; i++){
						if(i%4<2){
							EZB_DrawLaser(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 8, angle, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_LASER);
					for(i=0; i<20; i++){
						EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 8, angle, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==16){ //Big Laser
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					for(i=0; i<60; i++){
						if(i%4<2){
							EZB_DrawLaser(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 40, angle, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_LASER);
					for(i=0; i<40; i++){
						EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 40, angle, ghost->WeaponDamage*2, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==17){ //Laser Spread
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = (w*8+h*8)/2;
					for(i=0; i<40; i++){
						for(j=-2; j<=2; j++){
							if(i%4<2){
								x = CenterX(ghost)+VectorX(k, angle+30*j);
								y = CenterY(ghost)+VectorY(k, angle+30*j);
								EZB_DrawLaser(LAYER_EZB_LASER, x, y, 6, angle+30*j, C_EZB_LASER3);
							}
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_LASER);
					for(i=0; i<25; i++){
						for(j=-2; j<=2; j++){
							x = CenterX(ghost)+VectorX(k, angle+30*j);
							y = CenterY(ghost)+VectorY(k, angle+30*j);
							EZB_Laser3Color(LAYER_EZB_LASER, x, y, 6, angle+30*j, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==18){ //Laser Cross
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					k = Choose(-1, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())+45;
					Game->PlaySound(SFX_EZB_LASER);
					for(i=0; i<40; i++){
						if(Distance(CenterX(ghost), CenterY(ghost), 128, 88)>8){
							Ghost_MoveAtAngle(Angle(CenterX(ghost), CenterY(ghost), 128, 88), 0.8, 0);
						}
						for(j=0; j<4; j++){
							if(i%4<2){
								EZB_DrawLaser(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 6, angle+90*j, C_EZB_LASER3);
							}
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(i=0; i<30; i++){
						for(j=0; j<4; j++){
							EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 6, angle+90*j, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(i=0; i<30; i++){
						for(j=0; j<4; j++){
							EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 6, angle+90*j, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						}
						angle += k;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(i=0; i<120; i++){
						for(j=0; j<4; j++){
							EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 6, angle+90*j, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						}
						angle += k*1.25;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(i=0; i<30; i++){
						for(j=0; j<4; j++){
							EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 6, angle+90*j, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						}
						angle += k;
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==19){ //Summon 1 Enemy
					if ( Screen->NumNPCs() < EZB_TOTAL_SUMMON_CAP && EZB_NumSummons(summons) < EZB_SUMMON_CAP ) {
						EZB_FiringAnim(this, ghost, barrierShift, 0);
						Game->PlaySound(SFX_EZB_SUMMON);
						enem = CreateNPCAt(special, CenterX(ghost)-8, CenterY(ghost)-8);
						EZB_AddSummon(enem, summons);
						EZB_Waitframes(this, ghost, barrierShift, 24);
					}
				}
				if(attack==20){ //Summon 2 Enemies
					if ( Screen->NumNPCs() < EZB_TOTAL_SUMMON_CAP && EZB_NumSummons(summons) < EZB_SUMMON_CAP ) {
						EZB_FiringAnim(this, ghost, barrierShift, 0);
						Game->PlaySound(SFX_EZB_SUMMON);
						for(i=0; i<2; i++){
							enem = CreateNPCAt(special, CenterX(ghost)-8+Rand(-4, 4), CenterY(ghost)-8+Rand(-4, 4));
							EZB_AddSummon(enem, summons);
						}
						EZB_Waitframes(this, ghost, barrierShift, 24);
					}
				}
				if(attack==21){ //Summon 3 Enemies
					if ( Screen->NumNPCs() < EZB_TOTAL_SUMMON_CAP && EZB_NumSummons(summons) < EZB_SUMMON_CAP ) {
						EZB_FiringAnim(this, ghost, barrierShift, 0);
						Game->PlaySound(SFX_EZB_SUMMON);
						for(i=0; i<3; i++){
							enem = CreateNPCAt(special, CenterX(ghost)-8+Rand(-4, 4), CenterY(ghost)-8+Rand(-4, 4));
							EZB_AddSummon(enem, summons);
						}
						EZB_Waitframes(this, ghost, barrierShift, 24);
					}
				}
				if(attack==22){ //Homing Shot
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					eweapon wpn = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 100);
					SetEWeaponMovement(wpn, EWM_HOMING, DegtoRad(2), 120);
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==23){ //5 Aimed Shots (With Delays)
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					for(i=0; i<5; i++){
						EZB_FaceLink(this, ghost, barrierShift);
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 200);
						EZB_Waitframes(this, ghost, barrierShift, 25);
					}
				}
				if(attack==24){ //10 Aimed Shots (Quick)
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					for(i=0; i<10; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 200);
						EZB_Waitframes(this, ghost, barrierShift, 6);
					}
				}
				if(attack==25){ //Aimed Bullet Circle
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					for(i=0; i<12; i++){
						eweapon wpn = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, 360/12*i, 200);
						SetEWeaponMovement(wpn, EWM_HOMING_REAIM, 1, 30);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==26){ //4 Way Shot (Normal)
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					for(i=0; i<4; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, 90*i, 150);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==27){ //4 Way Shot (Diagonal)
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					for(i=0; i<4; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, 45+90*i, 150);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==28){ //8 Way Shot
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					for(i=0; i<8; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, 45*i, 150);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==29){ //Bullet Storm
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = 0;
					if ( CenterLinkX() < 128 )
						angle = 180;
					for(i=0; i<20; i++){
						if ( angle == 0 )
							EZB_Fire(this, ghost, barrierShift, 0, Rand(8, 152), angle, 250);
						else
							EZB_Fire(this, ghost, barrierShift, 240, Rand(8, 152), angle, 250);
						EZB_Waitframes(this, ghost, barrierShift, 8);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==30){ //Laser Storm
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					k = Rand(8, 152);
					for(i=0; i<35; i++){
						if(i%4<2){
							EZB_DrawLaser(LAYER_EZB_LASER, -32, k, 8, 0, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(j=0; j<8; j++){
						Game->PlaySound(SFX_EZB_LASER);
						y = k;
						k = Rand(8, 152);
						while(k-y > -40 && k-y < 40) { //make sure next laser is not too close to current laser
							k = Rand(8, 152);
						}
						for(i=0; i<35; i++){
							if(i<20){
								EZB_Laser3Color(LAYER_EZB_LASER, -32, y, 8, 0, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
							}
							if(j<7){ //dont show the last laser
								if(i%4<2){
									EZB_DrawLaser(LAYER_EZB_LASER, -32, k, 8, 0, C_EZB_LASER3);
								}
							}
							EZB_Waitframe(this, ghost, barrierShift);
						}
					}
				}
				if(attack==31){ //Laser Expansion
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					k = 0;
					while(true){
						for(i=0; i<30; i++){
							for(j=-1; j<=1; j+=2){
								if(i%4<2){
									EZB_DrawLaser(LAYER_EZB_LASER, CenterX(ghost)+24*k*j, -32, 12, 90, C_EZB_LASER3);
								}
							}
							EZB_Waitframe(this, ghost, barrierShift);
						}
						Game->PlaySound(SFX_EZB_LASER);
						for(i=0; i<20; i++){
							for(j=-1; j<=1; j+=2){
								EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost)+24*k*j, -32, 12, 90, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
							}
							EZB_Waitframe(this, ghost, barrierShift);
						}
						k++;
						if ( CenterX(ghost)+24*k*-1 < 16 && CenterX(ghost)+24*k > 224 || k > 10 )
							break;
                        //stop if Link has crossed the attack
                        if ( k > 2 && Link->X+8-16 > CenterX(ghost)+24*k*-1 && Link->X+8+16 < CenterX(ghost)+24*k )
                            break;
					}
				}
				if(attack==32){ //2 Shot Spread 40 degrees
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					for(i=0; i<2; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())-20+40*i, 250);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==33){ //Bash
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = 1;
					Ghost_Data = combo;
					Game->PlaySound(SFX_EZB_DASH);
					for(i=0; i<10; i++){
						k = Min(k+0.5, 5);
						Ghost_MoveAtAngle(angle, k, 0);
						EZB_Trail(this, ghost, barrierShift);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==34){ //Shooting Dash
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = 2;
					Game->PlaySound(SFX_EZB_DASH);
					i = 0;
					Ghost_Data = combo;
					while(EZB_CanMoveAngle(angle)){
						i++;
						k = Min(k+0.2, 5);
						Ghost_MoveAtAngle(angle, k, 0);
						if(i%4==0){
							if(ghost->Weapon==WPN_ENEMYFLAME||ghost->Weapon==WPN_ENEMYFIRETRAIL){
								EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 0);
							}
							else{
								EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 150);
							}
						}
						EZB_Trail(this, ghost, barrierShift);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==35){ //Double Dash
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = 2;
					Game->PlaySound(SFX_EZB_DASH);
					i = 0;
					Ghost_Data = combo;
					for(i=0; i<40; i++){
						k = Min(k+0.1, 4);
						Ghost_MoveAtAngle(angle, k, 0);
						EZB_Trail(this, ghost, barrierShift);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_FaceLink(this, ghost, barrierShift);
					k = 2;
					Game->PlaySound(SFX_EZB_DASH);
					i = 0;
					Ghost_Data = combo;
					for(i=0; i<40; i++){
						j = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
						if(i<20){
							if(Abs(EZB_AngDiff(angle, j))>1)
								angle = WrapDegrees(angle+1*Sign(EZB_AngDiff(angle, j)));
						}
						k = Min(k+0.1, 4);
						Ghost_MoveAtAngle(angle, k, 0);
						EZB_Trail(this, ghost, barrierShift);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==36){ //Jump
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					Game->PlaySound(SFX_JUMP);
					Ghost_Jump = 2.6;
					dist = Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = 2;
					if(dist<32)
						k = 0.5;
					else if(dist<64)
						k = 1;
					else if(dist<96)
						k = 2;
					else if(dist<128)
						k = 3;
					else
						k = 4;
					while(Ghost_Jump>0||Ghost_Z>0){
						Ghost_MoveAtAngle(angle, k, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==37){ //Double Jump
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					Game->PlaySound(SFX_JUMP);
					Ghost_Jump = 2.6;
					dist = Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = 2;
					if(dist<32)
						k = 0.5;
					else if(dist<64)
						k = 1;
					else if(dist<96)
						k = 2;
					else if(dist<128)
						k = 3;
					else
						k = 4;
					Ghost_Data = combo;
					while(Ghost_Jump>0||Ghost_Z>0){
						Ghost_MoveAtAngle(angle, k, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					
					Game->PlaySound(SFX_JUMP);
					Ghost_Jump = 2.6;
					while(Ghost_Jump>0||Ghost_Z>0){
						Ghost_MoveAtAngle(angle, k/2, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==38){ //Jump, Shockwave
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					
					Game->PlaySound(SFX_JUMP);
					Ghost_Jump = 3.2;
					dist = Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = 2;
					if(dist<32)
						k = 0.5;
					else if(dist<64)
						k = 1;
					else if(dist<96)
						k = 2;
					else if(dist<128)
						k = 3;
					else
						k = 4;
					
					Ghost_Data = combo;
					while(Ghost_Jump>0||Ghost_Z>0){
						Ghost_MoveAtAngle(angle, k, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_SHOCKWAVE);
					for(i=0; i<64+32; i+=3){
						EZB_Shockwave(2, CenterX(ghost), CenterY(ghost), i, 64, 12, ghost->WeaponDamage, C_EZB_SHOCKWAVE1, C_EZB_SHOCKWAVE2, C_EZB_SHOCKWAVE3);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					
				}
				if(attack==39){ //High Jump, Shockwave
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					EZB_FaceLink(this, ghost, barrierShift);
					
					Ghost_Data = combo;
					Game->PlaySound(SFX_JUMP);
					for(i=0; i<176; i+=4){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost));
							y = Sign(CenterLinkY()-CenterY(ghost));
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z += 4;
						Ghost_Jump = 0;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(i=0; i<180; i++){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.5;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.5;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Jump = 0;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_FALL);
					while(Ghost_Z>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.2;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.2;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z = Max(Ghost_Z-4, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_SHAKE);
					Screen->Quake = 20;
					Game->PlaySound(SFX_EZB_SHOCKWAVE);
					for(i=0; i<80+48; i+=6){
						EZB_Shockwave(2, CenterX(ghost), CenterY(ghost), i, 80, 16, ghost->WeaponDamage, C_EZB_SHOCKWAVE1, C_EZB_SHOCKWAVE2, C_EZB_SHOCKWAVE3);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==40){ //High Jump, Rocks Fall
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					EZB_FaceLink(this, ghost, barrierShift);
					
					Ghost_Data = combo;
					Game->PlaySound(SFX_JUMP);
					for(i=0; i<176; i+=4){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost));
							y = Sign(CenterLinkY()-CenterY(ghost));
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z += 4;
						Ghost_Jump = 0;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(i=0; i<120; i++){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.5;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.5;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Jump = 0;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_FALL);
					while(Ghost_Z>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.2;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.2;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z = Max(Ghost_Z-4, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_SHAKE);
					Screen->Quake = 20;
					for(i=0; i<30; i++){
						e = EZB_Fire(this, ghost, barrierShift, Rand(16, 224), Rand(16, 144), Rand(360), Rand(50), EWF_SHADOW);
						SetEWeaponMovement(e, EWM_FALL, 176, EWMF_DIE);
						SetEWeaponDeathEffect(e, EWD_EXPLODE, e->Damage);
						EZB_Waitframes(this, ghost, barrierShift, Rand(2, 6));
					}
				}
				if(attack==41){ //High Jump, Enemies Fall
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					EZB_FaceLink(this, ghost, barrierShift);
					
					Ghost_Data = combo;
					Game->PlaySound(SFX_JUMP);
					for(i=0; i<176; i+=4){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost));
							y = Sign(CenterLinkY()-CenterY(ghost));
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z += 4;
						Ghost_Jump = 0;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(i=0; i<120; i++){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.5;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.5;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Jump = 0;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_FALL);
					while(Ghost_Z>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.2;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.2;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z = Max(Ghost_Z-4, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_SHAKE);
					Screen->Quake = 20;
					k = Rand(4, 7);
					for(i=0; i<k&&(Screen->NumNPCs() < EZB_TOTAL_SUMMON_CAP && EZB_NumSummons(summons) < EZB_SUMMON_CAP); i++){
						j = Rand(176);
						for(m=0; m<352&&!EZB_CanPlace(this, ghost, ComboX(j), ComboY(j), 16, 16); m++){
							if(k<176)
								j = Rand(176);
							else
								j = m-176;
						}
						Game->PlaySound(SFX_FALL);
						enem = CreateNPCAt(special, ComboX(j), ComboY(j));
						EZB_AddSummon(enem, summons);
						enem->Z = 176;
						EZB_Waitframes(this, ghost, barrierShift, Rand(6, 17));
					}
				}
				if(attack==42){ //Chase
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					Ghost_Data = combo;
					for(i=0; i<300; i++){
						angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
						Ghost_MoveAtAngle(angle, 1, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==43){ //Backstep
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterLinkX(), CenterLinkY(), CenterX(ghost), CenterY(ghost));
					x = Ghost_X+VectorX(32, angle);
					y = Ghost_Y+VectorY(32, angle);
					if(EZB_CanPlace(this, ghost, x, y)){
						k = 3;
						Ghost_Data = combo;
						Game->PlaySound(SFX_EZB_BACKSTEP);
						for(i=0; i<10&&EZB_CanMoveAngle(angle); i++){
							angle = Angle(CenterLinkX(), CenterLinkY(), CenterX(ghost), CenterY(ghost));
							k = Min(k+0.5, 5);
							Ghost_MoveAtAngle(angle, k, 0);
							EZB_FaceLink(this, ghost, barrierShift);
							EZB_Trail(this, ghost, barrierShift);
							EZB_Waitframe(this, ghost, barrierShift);
						}
					}
					else{
						EZB_FaceLink(this, ghost, barrierShift);
						EZB_FiringAnim(this, ghost, barrierShift, 1);
						EZB_FaceLink(this, ghost, barrierShift);
						angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
						k = 2;
						Ghost_Data = combo;
						Game->PlaySound(SFX_EZB_DASH);
						while(EZB_CanMoveAngle(angle)){
							k = Min(k+0.2, 5);
							Ghost_MoveAtAngle(angle, k, 0);
							EZB_Trail(this, ghost, barrierShift);
							EZB_Waitframe(this, ghost, barrierShift);
						}
					}
				}
				//attack == 44 //Constant Attack (Fireball, Directional)
				//attack == 45 //Constant Attack (Fireball, Angular)
				//attack == 46 //Constant Attack (Summon)
				//attack == 47 //Constant Attack (4 Way, HV)
				//attack == 48 //Constant Attack (4 Way, Diag)
				if(attack==49){ //Mega Laser
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					for(i=0; i<90; i++){
						if(i%4<2){
							EZB_DrawLaser(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 64, angle, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_LASER);
					for(i=0; i<40; i++){
						for(j=0; j<4; j++){
							x = Ghost_X+Sign(VectorX(1, angle+180));
							y = Ghost_Y+Sign(VectorY(1, angle+180));
							if(EZB_CanPlace(this, ghost, x, y)){
								Ghost_MoveAtAngle(angle+180, 1, 0);
							}
						}
						EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 64, angle, ghost->WeaponDamage*2, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				//attack = 50 //Barrier Shift
				//attack = 51 //Enemy Shift
				if(attack==52){ //Flying Slam, Shockwave
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					EZB_FaceLink(this, ghost, barrierShift);
					
					Ghost_Jump = 4;
					Ghost_Data = combo;
					Game->PlaySound(SFX_JUMP);
					while(Ghost_Jump>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*1.3;
							y = Sign(CenterLinkY()-CenterY(ghost))*1.3;
							Ghost_MoveXY(x, y, 0);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					k = Ghost_Z;
					for(i=0; i<90; i++){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.7;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.7;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Jump = 0;
						Ghost_Z = k+2*Sin(16*i);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_FALL);
					while(Ghost_Z>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.3;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.3;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z = Max(Ghost_Z-4, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_SHAKE);
					Screen->Quake = 4;
					Game->PlaySound(SFX_EZB_SHOCKWAVE);
					for(i=0; i<48+48; i+=6){
						EZB_Shockwave(2, CenterX(ghost), CenterY(ghost), i, 48, 16, ghost->WeaponDamage, C_EZB_SHOCKWAVE1, C_EZB_SHOCKWAVE2, C_EZB_SHOCKWAVE3);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==53){ //Flying Slam, Rocks Fall
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					EZB_FaceLink(this, ghost, barrierShift);
					
					Ghost_Jump = 4;
					Ghost_Data = combo;
					Game->PlaySound(SFX_JUMP);
					while(Ghost_Jump>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*1.3;
							y = Sign(CenterLinkY()-CenterY(ghost))*1.3;
							Ghost_MoveXY(x, y, 0);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					k = Ghost_Z;
					for(i=0; i<90; i++){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.7;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.7;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Jump = 0;
						Ghost_Z = k+2*Sin(16*i);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_FALL);
					while(Ghost_Z>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.3;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.3;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z = Max(Ghost_Z-4, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_SHAKE);
					Screen->Quake = 4;
					for(i=0; i<10; i++){
						e = EZB_Fire(this, ghost, barrierShift, Rand(16, 224), Rand(16, 144), Rand(360), Rand(50), EWF_SHADOW);
						SetEWeaponMovement(e, EWM_FALL, 176, EWMF_DIE);
						SetEWeaponDeathEffect(e, EWD_EXPLODE, e->Damage);
						EZB_Waitframes(this, ghost, barrierShift, Rand(4, 12));
					}
				}
				if(attack==54){ //Flying Slam, Enemies Fall
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					EZB_FaceLink(this, ghost, barrierShift);
					
					Ghost_Jump = 4;
					Ghost_Data = combo;
					Game->PlaySound(SFX_JUMP);
					while(Ghost_Jump>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*1.3;
							y = Sign(CenterLinkY()-CenterY(ghost))*1.3;
							Ghost_MoveXY(x, y, 0);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					k = Ghost_Z;
					for(i=0; i<90; i++){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.7;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.7;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Jump = 0;
						Ghost_Z = k+2*Sin(16*i);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_FALL);
					while(Ghost_Z>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.3;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.3;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z = Max(Ghost_Z-4, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_SHAKE);
					Screen->Quake = 4;
					k = Rand(2, 3);
					for(i=0; i<k&&(Screen->NumNPCs() < EZB_TOTAL_SUMMON_CAP && EZB_NumSummons(summons) < EZB_SUMMON_CAP); i++){
						j = Rand(176);
						for(m=0; m<352&&!EZB_CanPlace(this, ghost, ComboX(j), ComboY(j), 16, 16); m++){
							if(k<176)
								j = Rand(176);
							else
								j = m-176;
						}
						Game->PlaySound(SFX_FALL);
						enem = CreateNPCAt(special, ComboX(j), ComboY(j));
						EZB_AddSummon(enem, summons);
						enem->Z = 176;
						EZB_Waitframes(this, ghost, barrierShift, Rand(6, 17));
					}
				}
				if(attack==55){ //Sine Wave Stream, Directional
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = EZB_DirAngle(Ghost_Dir);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					for(i=0; i<5; i++){
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 350);
						SetEWeaponMovement(e, EWM_SINE_WAVE, 16, 16);
						EZB_Waitframes(this, ghost, barrierShift, 8);
					}
					EZB_Waitframes(this, ghost, barrierShift, 12);
				}
				if(attack==56){ //Sine Wave Stream, Angular
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					for(i=0; i<5; i++){
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 250);
						SetEWeaponMovement(e, EWM_SINE_WAVE, 16, 16);
						EZB_Waitframes(this, ghost, barrierShift, 12);
					}
					EZB_Waitframes(this, ghost, barrierShift, 12);
				}
				if(attack==57){ //Sine Wave, 5 Shot
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Rand(360);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					j = Choose(-40, 40);
					for(k=0; k<3; k++){
						for(i=0; i<5; i++){
							e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+72*i, 250);
							SetEWeaponMovement(e, EWM_SINE_WAVE, j, 4);
						}
						EZB_Waitframes(this, ghost, barrierShift, 4);
					}
					EZB_Waitframes(this, ghost, barrierShift, 32);
				}
				if(attack==58){ //Reaim, Cross, Directional
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = EZB_DirAngle(Ghost_Dir);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					for(i=-1; i<=1; i+=2){
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+25*i, 300);
						j = 0;
						if(ghost->Weapon==WPN_ENEMYFIREBALL)
							j = 16;
						SetEWeaponLifespan(e, EWL_TIMER, 24+j);
						SetEWeaponDeathEffect(e, EWD_AIM_AT_LINK, 16);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==59){ //Reaim, Cross, Angular
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					for(i=-1; i<=1; i+=2){
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+45*i, 300);
						j = 0;
						if(ghost->Weapon==WPN_ENEMYFIREBALL)
							j = 16;
						SetEWeaponLifespan(e, EWL_TIMER, 24+j);
						SetEWeaponDeathEffect(e, EWD_AIM_AT_LINK, 16);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==60){ //Throw, Fixed Dist
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 150, EWF_UNBLOCKABLE|EWF_SHADOW);
					SetEWeaponMovement(e, EWM_THROW, 3.6, EWMF_DIE);
					EZB_SetEWeaponDeathEffect(e);
					
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==61){ //Throw, To Link
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 200, EWF_UNBLOCKABLE|EWF_SHADOW);
					SetEWeaponMovement(e, EWM_THROW, -1, EWMF_DIE);
					EZB_SetEWeaponDeathEffect(e);
					
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==62){ //Throw, To Link, Stream
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					
					for(i=0; i<16; i++){
						angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 200, EWF_UNBLOCKABLE|EWF_SHADOW);
						SetEWeaponMovement(e, EWM_THROW, -1, EWMF_DIE);
						EZB_SetEWeaponDeathEffect(e);
						
						EZB_Waitframes(this, ghost, barrierShift, 6);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==63){ //Throw, Five Shot
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(i=-2; i<=2; i++){
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+20*i, 200, EWF_UNBLOCKABLE|EWF_SHADOW);
						SetEWeaponMovement(e, EWM_THROW, 3.6, EWMF_DIE);
						EZB_SetEWeaponDeathEffect(e);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==64){ //Throw, 6 Shot, Volley
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(i=0; i<=6; i++){
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+Rand(-30, 30), Rand(100, 300), EWF_UNBLOCKABLE|EWF_SHADOW);
						SetEWeaponMovement(e, EWM_THROW, Rand(24, 36)/10, EWMF_DIE);
						EZB_SetEWeaponDeathEffect(e);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==65){ //Throw, Splash
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(i=0; i<=18; i++){
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Rand(360), Rand(100, 400), EWF_UNBLOCKABLE|EWF_SHADOW);
						SetEWeaponMovement(e, EWM_THROW, Rand(24, 36)/10, EWMF_DIE);
						EZB_SetEWeaponDeathEffect(e);
					}
				}
				if(attack==66){ //8 Shots, Line, Directional
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					for(i=0; i<8; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir), 200+400*(i/7));
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==67){ //8 Shots, Line, Angular
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(i=0; i<8; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 200+400*(i/7));
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==68){ //Teleport and Shoot
					EZB_Teleport(this, ghost, barrierShift);
					
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 150);
					
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==69){ //Teleport and Shoot Triple Shot
					EZB_Teleport(this, ghost, barrierShift);
					
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					for(i=-1; i<=1; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+20*i, 250);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==70){ //Teleport 3 Times, Shoot 8 Shots in a line
					for(i=0; i<3; i++){
						EZB_Waitframes(this, ghost, barrierShift, 4);
						EZB_Teleport(this, ghost, barrierShift);
					}
					
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(i=0; i<8; i++){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 200+400*(i/7));
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				
				if(barrierShift[200]){
					Game->PlaySound(SFX_EZB_BARRIERSHIFT);
					if(barrierShift[200]==2)
						EZB_Barriershift_Load(ghost, barrierShift, false);
					else
						EZB_Barriershift_Load(ghost, barrierShift, true);
				
					if(barrierShift[200]==2){
						//When morphing into a different enemy, reload all init stuff
						Ghost_UnsetFlag(GHF_8WAY);
						Ghost_UnsetFlag(GHF_4WAY);
						Ghost_UnsetFlag(GHF_NO_FALL);
						Ghost_UnsetFlag(GHF_IGNORE_ALL_TERRAIN);
						Ghost_UnsetFlag(GHF_FLYING_ENEMY);
						Ghost_UnsetFlag(GHF_FAKE_Z);
						Ghost_UnsetFlag(GHF_WATER_ONLY);
						Ghost_UnsetFlag(GHF_KNOCKBACK);
						Ghost_UnsetFlag(GHF_FAKE_Z);
						Ghost_UnsetFlag(GHF_CLOCK);
						Ghost_UnsetFlag(GHF_STUN);
						
						movementStyle = barrierShift[300];
						attack1 = barrierShift[301];
						attack2 = barrierShift[302];
						attack3 = barrierShift[303];
						shaveHitbox = barrierShift[304];
						special = barrierShift[305];
						size = barrierShift[306];
						fireSFX = barrierShift[307];
						fireSPR = barrierShift[308];
						flags = barrierShift[309];
						
						constantAttack = 0;
						doConstantAttack = 0;
						
						//Certain attacks in Attack 1 do a constant attack instead
						//This is triggered at certain parts of the enemy's walk pattern
						if(attack1==44)
							constantAttack = 44;
						else if(attack1==45)
							constantAttack = 45;
						else if(attack1==46)
							constantAttack = 46;
						else if(attack1==47)
							constantAttack = 47;
						else if(attack1==48)
							constantAttack = 48;
						
						if(attack1==50||attack1==51){
							EZB_Barriershift_Store(ghost, special, barrierShift);
							if(attack1==51)
								barrierShift[200] = 2;
						}
						
						//If there's a constant attack, shift all other attacks down
						if(constantAttack>0||(attack1==50||attack1==51)){
							attack1 = attack2;
							attack2 = attack3;
							attack3 = 0;
						}
						
						shaveX = shaveHitbox&1111b;
						shaveY = Floor(shaveHitbox>>4)&1111b;
						
						//An enemy with no collision uses stun to turn it off and so cannot be stunned normally
						if(!(flags&EZBF_NOCOLL)&&!(flags&EZBF_NOSTUN)){
							Ghost_SetFlag(GHF_STUN);
							Ghost_SetFlag(GHF_CLOCK);
						}
						
						w = size&1111b;
						h = (size>>4)&1111b;
						if(h==0)
							h = w;
						w = Clamp(w, 1, 4);
						h = Clamp(h, 1, 4);
							
						combo = barrierShift[310];
						if(Ghost_TileWidth!=w||Ghost_TileHeight!=h)
							Ghost_Transform(this, ghost, -1, -1, w, h);
						Ghost_SetHitOffsets(ghost, shaveY, shaveY, shaveX, shaveX);
						
						if(flags&EZBF_8WAY)
							Ghost_SetFlag(GHF_8WAY);
						else if(flags&EZBF_4WAY)
							Ghost_SetFlag(GHF_4WAY);
						if(flags&EZBF_NOFALL)
							Ghost_SetFlag(GHF_NO_FALL);
						if(flags&EZBF_FLYING){
							Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
							Ghost_SetFlag(GHF_FLYING_ENEMY);
							this->Flags[FFCF_OVERLAY] = true;
							if(EZB_FLYING_ZPOS&&(flags&EZBF_NOFALL)&&!IsSideview()){
								Ghost_SetFlag(GHF_FAKE_Z);
								Ghost_Z = 8;
							}
						}
						else if(flags&EZBF_AQUATIC){
							Ghost_SetFlag(GHF_WATER_ONLY);
						}
						if(flags&EZBF_KNOCKBACK){
							Ghost_SetFlag(GHF_KNOCKBACK);
						}
						if(EZB_ALWAYS_FAKE_Z)
							Ghost_SetFlag(GHF_FAKE_Z);
						
						stepCounter = -1;
						attackCooldown = ghost->Haltrate*10;
						stepAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
						stepCooldown = ghost->Rate;
						vX = 0; vY = 0;
						int lastAttack = -1;
						
						if(movementStyle==4){
							angle = Rand(360);
							vX = VectorX(ghost->Step/100, angle);
							vY = VectorY(ghost->Step/100, angle);
						}
						if(movementStyle==11){
							stepAngle = Rand(4);
						}
					}
				}
				Ghost_Data = combo;
				
				lastAttack = attack;
				attackCooldown = ghost->Haltrate*10;
				if(movementStyle==4){ //Wall bounce
					angle = Rand(360);
					vX = VectorX(ghost->Step/100, angle);
					vY = VectorY(ghost->Step/100, angle);
				}
			}
			EZB_Waitframe(this, ghost, barrierShift);
		}
	}
	bool EZB_CanMoveAngle(int angle){
		int vx = VectorX(10, angle);
		int vy = VectorY(10, angle);
		if((vx<0&&!Ghost_CanMove(DIR_LEFT, 1, 0))||(vx>0&&!Ghost_CanMove(DIR_RIGHT, 1, 0)))
			return false;
		if((vy<0&&!Ghost_CanMove(DIR_UP, 1, 0))||(vy>0&&!Ghost_CanMove(DIR_DOWN, 1, 0)))
			return false;
		return true;
	}
	void EZB_FiringAnim(ffc this, npc ghost, int barrierShift, int delayType){
		int movementStyle = barrierShift[300];
		int flags = barrierShift[309];
		int combo = barrierShift[310];
		if(flags&EZBF_8WAY)
			Ghost_Data = combo+8;
		else if(flags&EZBF_4WAY)
			Ghost_Data = combo+4;
		else
			Ghost_Data = combo+1;
		
		if(delayType==0){ //Normal delay
			if(movementStyle!=0) //Halting walk doesn't need a delay for most attacks
				EZB_Waitframes(this, ghost, barrierShift, EZB_WINDUP_ATTACK);
		}
		else if(delayType==1){ //Medium delay (shake)
			if(movementStyle!=0){
				int dX = 0;
				int dY = 0;
				for(int i=0; i<EZB_WINDUP_ATTACK_MED; i++){
					if(EZB_DO_WINDUP_SHAKE>1){
						Ghost_X -= dX;
						Ghost_Y -= dY;
						dX = Rand(-1, 1);
						dY = Rand(-1, 1);
						Ghost_X += dX;
						Ghost_Y += dY;
					}
					EZB_Waitframe(this, ghost, barrierShift);
				}
				Ghost_X -= dX;
				Ghost_Y -= dY;
			}
		}
		else if(delayType==2){ //Big delay (shake)
			int dX = 0;
			int dY = 0;
			for(int i=0; i<EZB_WINDUP_ATTACK_STRONG; i++){
				if(EZB_DO_WINDUP_SHAKE>0){
					Ghost_X -= dX;
					Ghost_Y -= dY;
					dX = Rand(-2, 2);
					dY = Rand(-2, 2);
					Ghost_X += dX;
					Ghost_Y += dY;
				}
				EZB_Waitframe(this, ghost, barrierShift);
			}
			Ghost_X -= dX;
			Ghost_Y -= dY;
		}
	}
	void EZB_Trail(ffc this, npc ghost, int barrierShift){
		if(!EZB_ENABLE_SPEEDTRAILS)
			return;
		
		int flags = barrierShift[309];
		int tile = Game->ComboTile(Ghost_Data);
		if(flags&EZBF_4WAY||flags&EZBF_8WAY)
			tile = Game->ComboTile(Ghost_Data+Ghost_Dir);
		lweapon trail = CreateLWeaponAt(LW_SCRIPT10, ghost->X+ghost->DrawXOffset, ghost->Y+ghost->DrawYOffset);
		trail->Extend = 3;
		trail->TileWidth = ghost->TileWidth;
		trail->TileHeight = ghost->TileHeight;
		trail->DrawYOffset = 0;
		trail->CSet = this->CSet;
		trail->Tile = tile;
		trail->OriginalTile = tile;
		trail->DrawStyle = DS_PHANTOM;
		trail->DeadState = 8;
	}
	int EZB_DirAngle(int dir){
		if(dir==DIR_UP)
			return -90;
		else if(dir==DIR_DOWN)
			return 90;
		else if(dir==DIR_LEFT)
			return 180;
		else if(dir==DIR_LEFTUP)
			return -135;
		else if(dir==DIR_RIGHTUP)
			return -45;
		else if(dir==DIR_LEFTDOWN)
			return 135;
		else if(dir==DIR_RIGHTDOWN)
			return 45;
		else
			return 0;
	}
	eweapon EZB_Fire(ffc this, npc ghost, int barrierShift, int x, int y, int angle, int step){
		eweapon e = EZB_Fire(this, ghost, barrierShift, x, y, angle, step, 0);
		return e;
	}
	eweapon EZB_Fire(ffc this, npc ghost, int barrierShift, int x, int y, int angle, int step, int wflags){
		int flags = barrierShift[309];
		int type = EZB_WeaponTypeToID(ghost->Weapon);
		if(flags&EZBF_UNBLOCKABLE)
			wflags |= EWF_UNBLOCKABLE;
		int fireSFX = barrierShift[307];
		int fireSPR = barrierShift[308];
		if(fireSPR==0&&(type==EW_BEAM||type==EW_ARROW||type==EW_MAGIC||type==EW_BOMB||type==EW_SBOMB))
			wflags |= EWF_ROTATE;
		
		if(fireSPR>=2000){
			wflags |= EWF_ROTATE_360;
			fireSPR -= 2000;
		}
		else if(fireSPR>=1000){
			wflags |= EWF_ROTATE;
			fireSPR -= 000;
		}
		int sfx = fireSFX;
		if(fireSFX<=0)
			sfx = -1;
		int spr = fireSPR;
		if(fireSPR<=0)
			spr = -1;
			
		eweapon e = FireEWeapon(type, x, y, DegtoRad(angle), step, ghost->WeaponDamage, spr, sfx, wflags);
		return e;
	}
	int EZB_WeaponTypeToID(int wpnt){
		if(wpnt == WPN_ENEMYFLAME) 		return EW_FIRE;
		else if(wpnt == WPN_ENEMYWIND)		return EW_WIND;
		else if(wpnt == WPN_ENEMYFIREBALL)	return EW_FIREBALL;
		else if(wpnt == WPN_ENEMYARROW)		return EW_ARROW;
		else if(wpnt == WPN_ENEMYBRANG)		return EW_BRANG;
		else if(wpnt == WPN_ENEMYSWORD)		return EW_BEAM;
		else if(wpnt == WPN_ENEMYROCK)		return EW_ROCK;
		else if(wpnt == WPN_ENEMYMAGIC)		return EW_MAGIC;
		else if(wpnt == WPN_ENEMYBOMB)		return EW_BOMBBLAST; //flipped bomb and lit bomb in older versions of this file. -Z ( 12th February, 2019 )
		else if(wpnt == WPN_ENEMYSBOMB)		return EW_SBOMBBLAST;
		else if(wpnt == WPN_ENEMYLITBOMB)	return EW_BOMB;
		else if(wpnt == WPN_ENEMYLITSBOMB)	return EW_SBOMB;
		else if(wpnt == WPN_ENEMYFIRETRAIL)	return EW_FIRETRAIL;
		else if(wpnt == WPN_ENEMYFLAME2)	return EW_FIRE2;
		else if(wpnt == WPN_ENEMYFIREBALL2)	return EW_FIREBALL2;
		return -1;
	}
	void EZB_SetEWeaponDeathEffect(eweapon e){
		if(e->ID==EW_FIRE||e->ID==EW_FIRE2){
			SetEWeaponDeathEffect(e, EWD_8_FIRES, -1);
		}
		else if(e->ID==EW_FIRETRAIL){
			SetEWeaponDeathEffect(e, EWD_FIRE, -1);
		}
		else if(e->ID==EW_BOMB){
			SetEWeaponDeathEffect(e, EWD_EXPLODE, e->Damage);
		}
		else if(e->ID==EW_SBOMB){
			SetEWeaponDeathEffect(e, EWD_SBOMB_EXPLODE, e->Damage);
		}
		else if(e->ID==EW_ARROW){
			SetEWeaponDeathEffect(e, EWD_4_FIREBALLS_HV, -1);
		}
		else if(e->ID==EW_MAGIC){
			SetEWeaponDeathEffect(e, EWD_AIM_AT_LINK, 16);
		}
		else{
			SetEWeaponDeathEffect(e, EWD_VANISH, -1);
		}
	}
	void EZB_DrawTeleport(ffc this, npc ghost, int barrierShift, int x, int y, int frame, int maxFrame){
		int w = Ghost_TileWidth;
		int h = Ghost_TileHeight;
		
		int flags = barrierShift[309];
		
		int cmb = Ghost_Data;
		if(flags&EZBF_4WAY||flags&EZBF_8WAY)
			cmb+=Ghost_Dir;
		
		int layer = 2;
		if(ScreenFlag(1, 4)) //Layer -2
			layer = 1;
		int i = frame/maxFrame;
		int op = 128;
		if(frame>maxFrame-8)
			op = 64;
		Screen->DrawCombo(layer, x+w*8*i, y-h*24*i, cmb, w, h, this->CSet, w*16-w*16*i, h*16+h*24*i, 0, 0, 0, -1, 0, true, op);
	}
	void EZB_Teleport(ffc this, npc ghost, int barrierShift){
		int size = barrierShift[306];
		int flags = barrierShift[309];
		int combo = barrierShift[310];
		int w = size&1111b;
		int h = (size>>4)&1111b;
		if(h==0)
			h = w;
		w = Clamp(w, 1, 4);
		h = Clamp(h, 1, 4);
		
		Game->PlaySound(SFX_EZB_TELEPORT);
		int tc;
		ghost->CollDetection = false;
		ghost->DrawYOffset = -1000;
		int oldCombo = Ghost_Data;
		for(int i=0; i<16; i++){
			if(EZB_TELEPORT_TYPE==1){
				EZB_DrawTeleport(this, ghost, barrierShift, Ghost_X, Ghost_Y-2, i, 16);
			}
			else if(EZB_TELEPORT_TYPE==2){
				ghost->DrawYOffset = -2;
				if(flags&EZBF_4WAY)
					Ghost_Data = combo+8;
				else if(flags&EZBF_8WAY)
					Ghost_Data = combo+16;
				else
					Ghost_Data = combo+2;
			}
			else{
				if(i%2==0)
					ghost->DrawYOffset = -1000;
				else
					ghost->DrawYOffset = -2;
			}
			EZB_Waitframe(this, ghost, barrierShift);
		}
		ghost->DrawYOffset = -1000;
		tc = Rand(176);
		for(int i=0; i<352&&(!EZB_CanPlace(this, ghost, ComboX(tc), ComboY(tc))||Distance(ComboX(tc)+ghost->HitWidth/2, ComboY(tc)+ghost->HitHeight/2, CenterLinkX(), CenterLinkY())<((w+h)/2)*8+32); i++){
			if(i>=176)
				tc = i-176;
			else
				tc = Rand(176);
		}
		Ghost_X = ComboX(tc);
		Ghost_Y = ComboY(tc);
		EZB_Waitframe(this, ghost, barrierShift);
		EZB_FaceLink(this, ghost, barrierShift);
		for(int i=0; i<16; i++){
			if(EZB_TELEPORT_TYPE==1){
				EZB_DrawTeleport(this, ghost, barrierShift, Ghost_X, Ghost_Y-2, 16-i, 16);
			}
			else if(EZB_TELEPORT_TYPE==2){
				ghost->DrawYOffset = -2;
				if(flags&EZBF_4WAY)
					Ghost_Data = combo+8;
				else if(flags&EZBF_8WAY)
					Ghost_Data = combo+16;
				else
					Ghost_Data = combo+2;
			}
			else{
				if(i%2==0)
					ghost->DrawYOffset = -1000;
				else
					ghost->DrawYOffset = -2;
			}
			EZB_Waitframe(this, ghost, barrierShift);
		}
		ghost->DrawYOffset = -2;
		Ghost_Data = oldCombo;
		ghost->CollDetection = true;
	}	
	int EZB_AngleDir(ffc this, npc ghost, int barrierShift, int angle){
		int flags = barrierShift[309];
		if(flags&EZBF_8WAY)
			return AngleDir8(angle);
		else
			return AngleDir4(angle);
	}
	float EZB_AngDiff(float angle1, float angle2){
		// Get the difference between the two angles
		float dif = angle2 - angle1;
		
		// Compensate for the difference being outside of normal bounds
		if(dif >= 180)
			dif -= 360;
		else if(dif <= -180)
			dif += 360;
			
		return dif;
	}
	void EZB_FaceLink(ffc this, npc ghost, int barrierShift){
		int flags = barrierShift[309];
		if(flags&EZBF_8WAY)
			Ghost_Dir = AngleDir8(Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()));
		else
			Ghost_Dir = AngleDir4(Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()));
	}
	void EZB_FaceAngle(ffc this, npc ghost, int barrierShift, int angle){
		int flags = barrierShift[309];
		if(flags&EZBF_8WAY)
			Ghost_Dir = AngleDir8(angle);
		else
			Ghost_Dir = AngleDir4(angle);
	}
	bool EZB_CanPlace(ffc this, npc ghost, int X, int Y){
		for(int x=ghost->HitXOffset; x<=ghost->HitXOffset+ghost->HitWidth-1; x=Min(x+8, ghost->HitXOffset+ghost->HitWidth-1)){
			for(int y=ghost->HitYOffset; y<=ghost->HitYOffset+ghost->HitHeight-1; y=Min(y+8, ghost->HitYOffset+ghost->HitHeight-1)){
				if(!Ghost_CanMovePixel(X+x, Y+y))
					return false;
				if(y==ghost->HitYOffset+ghost->HitHeight-1)
					break;
			}
			if(x==ghost->HitXOffset+ghost->HitWidth-1)
				break;
		}
		return true;
	}
	bool EZB_CanPlace(ffc this, npc ghost, int X, int Y, int W, int H){
		for(int x=0; x<=W-1; x=Min(x+8, W-1)){
			for(int y=0; y<=H-1; y=Min(y+8, H-1)){
				if(!Ghost_CanMovePixel(X+x, Y+y))
					return false;
				if(y==H-1)
					break;
			}
			if(x==W-1)
				break;
		}
		return true;
	}
	bool EZB_RotRectCollision(float x1c, float y1c, float height1, float width1, float rot1, float x2c, float y2c, float height2, float width2, float rot2){
		float rad1=Sqrt(height1*height1+width1*width1);
		float rad2=Sqrt(height2*height2+width2*width2);
		float angle1=RadtoDeg(ArcSin(height1/rad1));
		float angle2=RadtoDeg(ArcSin(height2/rad2));
		float x1[4];
		float y1[4];
		float x2[4];
		float y2[4];
		float axisX[4];
		float axisY[4];
		float proj;
		float minProj1;
		float maxProj1;
		float minProj2;
		float maxProj2;
		x1[0]=x1c+rad1*Cos(rot1-angle1);
		y1[0]=y1c+rad1*Sin(rot1-angle1);
		x1[1]=x1c+rad1*Cos(rot1+angle1);
		y1[1]=y1c+rad1*Sin(rot1+angle1);
		x1[2]=x1c+rad1*Cos(rot1+180-angle1);
		y1[2]=y1c+rad1*Sin(rot1+180-angle1);
		x1[3]=x1c+rad1*Cos(rot1+180+angle1);
		y1[3]=y1c+rad1*Sin(rot1+180+angle1);
		x2[0]=x2c+rad2*Cos(rot2-angle2);
		y2[0]=y2c+rad2*Sin(rot2-angle2);
		x2[1]=x2c+rad2*Cos(rot2+angle2);
		y2[1]=y2c+rad2*Sin(rot2+angle2);
		x2[2]=x2c+rad2*Cos(rot2+180-angle2);
		y2[2]=y2c+rad2*Sin(rot2+180-angle2);
		x2[3]=x2c+rad2*Cos(rot2+180+angle2);
		y2[3]=y2c+rad2*Sin(rot2+180+angle2);
		axisX[0]=x1[0]-x1[1];
		axisY[0]=y1[0]-y1[1];
		axisX[1]=x1[2]-x1[1];
		axisY[1]=y1[2]-y1[1];
		axisX[2]=x2[0]-x2[1];
		axisY[2]=y2[0]-y2[1];
		axisX[3]=x2[2]-x2[1];
		axisY[3]=y2[2]-y2[1];
		// if(true){ //Debug draws
			// Screen->Rectangle(5, x1c-width1, y1c-height1, x1c+width1, y1c+height1, 1, -1, x1c, y1c, rot1, true, 128);
			// Screen->Rectangle(5, x2c-width2, y2c-height2, x2c+width2, y2c+height2, 2, -1, x2c, y2c, rot2, true, 128);
		// }
		for(int i=0; i<4; i++){
			proj=x1[0]*axisX[i]+y1[0]*axisY[i];
			minProj1=proj;
			maxProj1=proj;
			for(int j=1; j<4; j++){
				proj=x1[j]*axisX[i]+y1[j]*axisY[i];
				if(proj<minProj1)
					minProj1=proj;
				if(proj>maxProj1)
					maxProj1=proj;
			}
			proj=x2[0]*axisX[i]+y2[0]*axisY[i];
			minProj2=proj;
			maxProj2=proj;
			for(int j=1; j<4; j++){
				proj=x2[j]*axisX[i]+y2[j]*axisY[i];
				if(proj<minProj2)
					minProj2=proj;
				if(proj>maxProj2)
					maxProj2=proj;
			}
			if(maxProj2<minProj1 || maxProj1<minProj2)
				return false;
		}
		return true;
	}
	void EZB_DrawLaser(int layer, int x, int y, int width, int angle, int color){
		if(ScreenFlag(1, 4)&&layer==2) //Layer -2
			layer = 1;
		else if(ScreenFlag(1, 5)&&layer==3) //Layer -3
			layer = 4;
		Screen->Circle(layer, x+width, y, width, color, 1, x, y, angle, true, 128);
		Screen->Rectangle(layer, x+width, y-width, x+width+512, y+width, color, 1, x, y, angle, true, 128);
	}
	void EZB_DrawLaser3Color(int layer, int x, int y, int width, int angle, int color1, int color2, int color3){
		EZB_DrawLaser(layer, x, y, width, angle, color1);
		EZB_DrawLaser(layer, x, y, width/4*3, angle, color2);
		EZB_DrawLaser(layer, x, y, width/2, angle, color3);
	}
	bool EZB_LaserCollision(int x, int y, int width, int angle){
		int hitWidth = Max(1, width-3);
		int cX = x+VectorX(width, angle);
		int cY = y+VectorY(width, angle);
		if(Distance(CenterLinkX(), CenterLinkY(), cX, cY)<width)
			return true;
		return EZB_RotRectCollision(x+VectorX(width+128, angle), y+VectorY(width+128, angle), hitWidth, 128, angle, CenterLinkX(), CenterLinkY(), 4, 4, 0);
	}
	void EZB_Laser3Color(int layer, int x, int y, int width, int angle, int damage, int color1, int color2, int color3){
		if(ScreenFlag(1, 4)&&layer==2) //Layer -2
			layer = 1;
		else if(ScreenFlag(1, 5)&&layer==3) //Layer -3
			layer = 4;
		EZB_DrawLaser3Color(layer, x, y, width, angle, color1, color2, color3);
		if(EZB_LaserCollision(x, y, width, angle)){
			EZB_DamageLink(damage);
		}
	}
	void EZB_Shockwave(int layer, int x, int y, int rad1, int rad2, int rings, int damage, int color1, int color2, int color3){
		if(ScreenFlag(1, 4)&&layer==2) //Layer -2
			layer = 1;
		else if(ScreenFlag(1, 5)&&layer==3) //Layer -3
			layer = 4;
		int clr = Choose(color1, color2, color3);
		for(int i=0; i<rings; i++){
			if(rad1-i*2>0&&rad1-i*2<rad2){
				Screen->Circle(layer, x, y, rad1-i*2, clr, 1, 0, 0, 0, false, 128);
			}
		}
		int r = Min(rad1, rad2);
		if(Distance(CenterLinkX(), CenterLinkY(), x, y)<r){
			EZB_DamageLink(damage);
		}
	}
	void EZB_DamageLink(int damage){
		eweapon e = FireEWeapon(EW_SCRIPT10, Link->X+InFrontX(Link->Dir, 12), Link->Y+InFrontY(Link->Dir, 12), 0, 0, damage, -1, -1, EWF_UNBLOCKABLE);
		e->Dir = Link->Dir;
		e->DrawYOffset = -1000;
		SetEWeaponLifespan(e, EWL_TIMER, 1);
		SetEWeaponDeathEffect(e, EWD_VANISH, 0);
	}
	void EZB_Explode(ffc this, npc ghost, bool flash){
		int baseX=Ghost_X+ghost->DrawXOffset;
		int baseY=(Ghost_Y+ghost->DrawYOffset)-(Ghost_Z+ghost->DrawZOffset);
		
		__DeathAnimStart(this, ghost);
		__DeathAnimSFX(ghost->ID, ghost->X);
		
		if(flash)
			__Ghost_FlashCounter=10000;
		else
			__Ghost_FlashCounter=0;
		
		// One explosion every 16 frames, 15 times
		for(int i=0; i<15; i++)
		{
			EZB_CreateDeathExplosion(baseX+Rand(16*Ghost_TileWidth)-8, baseY+Rand(16*Ghost_TileHeight)-8);
			
			for(int j=0; j<16; j++)
			{
				Ghost_SetPosition(this, ghost); // Make sure it doesn't wander off
				if(flash)
					__Ghost_UpdateFlashing(this, ghost);
				Ghost_WaitframeLight(this, ghost);
			}
		}
		
		__DeathAnimEnd(this, ghost);
	}
	void EZB_CreateDeathExplosion(int x, int y){
		Game->PlaySound(SFX_BOMB);
		
		lweapon explosion=Screen->CreateLWeapon(LW_EZB_DEATHEXPLOSION);
		explosion->X = x-(WIDTH_EZB_DEATHEXPLOSION-1)*8;
		explosion->Y = y-(HEIGHT_EZB_DEATHEXPLOSION-1)*8;
		
		explosion->Extend = 3;
		explosion->TileWidth = WIDTH_EZB_DEATHEXPLOSION;
		explosion->TileHeight = HEIGHT_EZB_DEATHEXPLOSION;
		
		explosion->UseSprite(SPR_EZB_DEATHEXPLOSION);
		explosion->CollDetection = false;
		explosion->DeadState = explosion->NumFrames*explosion->ASpeed;
	}
	void EZB_Barriershift_Store(npc ghost, int newForm, int barrierShift){
		int i;
		
		npc n = CreateNPCAt(newForm, 128, -1000);
		
		barrierShift[000] = Ghost_CSet;
		barrierShift[001] = ghost->Damage;
		barrierShift[002] = ghost->WeaponDamage;
		barrierShift[003] = ghost->Hunger;
		barrierShift[004] = ghost->Rate;
		barrierShift[005] = ghost->Haltrate;
		barrierShift[006] = ghost->Homing;
		barrierShift[007] = ghost->Step;
		barrierShift[008] = ghost->Weapon;
		barrierShift[009] = ghost->ItemSet;
		barrierShift[010] = ghost->SFX;
		for(i=0; i<11; i++){
			barrierShift[011+i] = ghost->Attributes[i];
		}
		for(i=0; i<18; i++){
			barrierShift[022+i] = ghost->Defense[i];
		}
		
		barrierShift[100] = n->CSet;
		barrierShift[101] = n->Damage;
		barrierShift[102] = n->WeaponDamage;
		barrierShift[103] = n->Hunger;
		barrierShift[104] = n->Rate;
		barrierShift[105] = n->Haltrate;
		barrierShift[106] = n->Homing;
		barrierShift[107] = n->Step;
		barrierShift[108] = n->Weapon;
		barrierShift[109] = n->ItemSet;
		barrierShift[110] = n->SFX;
		for(i=0; i<11; i++){
			barrierShift[111+i] = n->Attributes[i];
		}
		for(i=0; i<18; i++){
			barrierShift[122+i] = n->Defense[i];
		}
		
		barrierShift[200] = 1;
		barrierShift[201] = 0;
		
		n->HP = -1000;
		n->DrawXOffset = -1000;
		n->DrawYOffset = -1000;
		n->ItemSet = 0;
		n->CollDetection = false;
		
		//Flag the enemy as already used by ghost.zh so it doesn't run a script
		n->Misc[__GHI_NPC_DATA] = 0x10000;
	}
	void EZB_Barriershift_Load(npc ghost, int barrierShift, bool onlyDefenses){
		int i;
		int startIndex = 0;
		if(barrierShift[201]==0)
			startIndex = 100;
		
		Ghost_CSet = barrierShift[startIndex+000];
		if(!onlyDefenses){
			ghost->Damage = barrierShift[startIndex+001];
			ghost->WeaponDamage = barrierShift[startIndex+002];
			ghost->Hunger = barrierShift[startIndex+003];
			ghost->Rate = barrierShift[startIndex+004];
			ghost->Haltrate = barrierShift[startIndex+005];
			ghost->Homing = barrierShift[startIndex+006];
			ghost->Step = barrierShift[startIndex+007];
			ghost->Weapon = barrierShift[startIndex+008];
			ghost->ItemSet = barrierShift[startIndex+009];
			ghost->SFX = barrierShift[startIndex+010];
			
			for(i=0; i<11; i++){
				barrierShift[300+i] = barrierShift[startIndex+011+i];
			}
		}
		
		for(i=0; i<18; i++){
			ghost->Defense[i] = barrierShift[startIndex+022+i];
		}
	
		if(barrierShift[201]==0)
			barrierShift[201] = 1;
		else
			barrierShift[201] = 0;
	}
	int EZB_NumSummons(npc summons){
		int count;
		for(int i=0; i<256; i++){
			if(summons[i]->isValid()){
				count++;
			}
		}
		return count;
	}
	void EZB_AddSummon(npc n, npc summons){
		for(int i=0; i<256; i++){
			if(!summons[i]->isValid()){
				summons[i] = n;
				return;
			}
		}
	}
	void EZB_Waitframes(ffc this, npc ghost, int barrierShift, int frames){
		for(int i=0; i<frames; i++){
			EZB_Waitframe(this, ghost, barrierShift);
		}
	}
	void EZB_Waitframe(ffc this, npc ghost, int barrierShift){
		int flags = barrierShift[309];
		if(flags&EZBF_NOCOLL){
			ghost->Stun = 60;
		}
		if(flags&EZBF_NOSTUN){
			ghost->Stun = 0;
		}
		
		if(flags&EZBF_EXPLODEEATH){
			if(SPR_EZB_DEATHEXPLOSION>0){
				if(!Ghost_Waitframe(this, ghost, false, false)){
					EZB_Explode(this, ghost, EZB_DEATH_FLASH);
					Quit();
				}
			}
			else
				Ghost_Waitframe(this, ghost, 1, true);
		}
		else
			Ghost_Waitframe(this, ghost);
	}
}

int Switch_Pressed(int x, int y, bool noLink){
	int xOff = 0;
	int yOff = 4;
	int xDist = 8;
	int yDist = 8;
	if(Abs(Link->X+xOff-x)<=xDist&&Abs(Link->Y+yOff-y)<=yDist&&Link->Z==0&&!noLink)
		return 1;
	if(Screen->MovingBlockX>-1){
		if(Abs(Screen->MovingBlockX-x)<=8&&Abs(Screen->MovingBlockY-y)<=8)
			return 1;
	}
	if(Screen->isSolid(x+4, y+4)||
		Screen->isSolid(x+12, y+4)||
		Screen->isSolid(x+4, y+12)||
		Screen->isSolid(x+12, y+12)){
		return 2;
	}
	return 0;
}

ffc script Switch_Secret{
	void run(int perm, int id, int sfx){
		int d;
		int db;
		if(id>0){
			d = Floor((id-1)/16);
			db = 1<<((id-1)%16);
		}
		if(perm){
			if(id>0){
				if(Screen->D[d]&db){
					this->Data++;
					Screen->TriggerSecrets();
					Quit();
				}
			}
			else if(Screen->State[ST_SECRET]){
				this->Data++;
				Quit();
			}
		}
		while(!Switch_Pressed(this->X, this->Y, false)){
			Waitframe();
		}
		this->Data++;
		Screen->TriggerSecrets();
		Game->PlaySound(SFX_SWITCH_PRESS);
		if(sfx==0)
			Game->PlaySound(SFX_SECRET);
		else if(sfx>0)
			Game->PlaySound(sfx);
		if(perm){
			if(id>0)
				Screen->D[d]|=db;
			else
				Screen->State[ST_SECRET] = true;
		}
	}
}

ffc script Switch_Remote{
	void run(int pressure, int id, int flag, int sfx){
		bool noLink;
		if(pressure==2){
			pressure = 1;
			noLink = true;
		}
		
		int data = this->Data;
		int i; int j; int k;
		int d;
		int db;
		if(id>0){
			d = Floor((id-1)/16);
			db = 1<<((id-1)%16);
		}
		int comboD[176];
		for(i=0; i<176; i++){
			if(Screen->ComboF[i]==flag){
				comboD[i] = Screen->ComboD[i];
				Screen->ComboF[i] = 0;
			}
		}
		if(id>0){
			if(Screen->D[d]&db){
				this->Data = data+1;
				for(i=0; i<176; i++){
					if(comboD[i]>0){
						Screen->ComboD[i] = comboD[i]+1;
					}
				}
				Quit();
			}
		}
		if(pressure){
			while(true){
				while(!Switch_Pressed(this->X, this->Y, noLink)){
					Waitframe();
				}
				this->Data = data+1;
				Game->PlaySound(SFX_SWITCH_PRESS);
				for(i=0; i<176; i++){
					if(comboD[i]>0){
						Screen->ComboD[i] = comboD[i]+1;
					}
				}
				while(Switch_Pressed(this->X, this->Y, noLink)){
					Waitframe();
				}
				this->Data = data;
				Game->PlaySound(SFX_SWITCH_RELEASE);
				for(i=0; i<176; i++){
					if(comboD[i]>0){
						Screen->ComboD[i] = comboD[i];
					}
				}
			}
		}
		else{
			while(!Switch_Pressed(this->X, this->Y, noLink)){
				Waitframe();
			}
			this->Data = data+1;
			Game->PlaySound(SFX_SWITCH_PRESS);
			if(sfx>0)
				Game->PlaySound(sfx);
			else
				Game->PlaySound(SFX_SECRET);
			for(i=0; i<176; i++){
				if(comboD[i]>0){
					Screen->ComboD[i] = comboD[i]+1;
				}
			}
			if(id>0){
				Screen->D[d] |= db;
			}
		}
	}
}

ffc script Switch_HitAll{
	void run(int switchCmb, int pressure, int perm, int id, int flag, int sfx, int switchID){
		bool noLink;
		if(pressure==2){
			pressure = 1;
			noLink = true;
		}
		
		int i; int j; int k;
		int d;
		int db;
		if(flag==0)
			id = 0;
		int comboD[176];
		if(id>0){
			d = Floor((id-1)/16);
			db = 1<<((id-1)%16);
			for(i=0; i<176; i++){
				if(Screen->ComboF[i]==flag){
					comboD[i] = Screen->ComboD[i];
					Screen->ComboF[i] = 0;
				}
			}
		}
		int switches[34];
		int switchD[34];
		int switchDB[34];
		switchD[0] = switchID;
		bool switchesPressed[34];
		k = SizeOfArray(switches)-2;
		for(i=0; i<176&&switches[0]<k; i++){
			if(Screen->ComboD[i]==switchCmb){
				j = 2+switches[0];
				switches[j] = i;
				if(!pressure&&switchID>0){
					switchD[j] = Floor((switchID+switches[0]-1)/16);
					switchDB[j] = 1<<((switchID+switches[0]-1)%16);
					if(Screen->D[switchD[j]]&switchDB[j]){
						switchesPressed[j] = true;
						Screen->ComboD[i] = switchCmb+1;
						switches[1]++;
					}
				}
				switches[0]++;
			}
		}
		if(perm){
			if(id>0){
				if(Screen->D[d]&db){
					for(i=2; i<switches[0]+2; i++){
						Screen->ComboD[switches[i]] = switchCmb+1;
						switchesPressed[i] = true;
					}
					for(i=0; i<176; i++){
						if(comboD[i]>0){
							Screen->ComboD[i] = comboD[i]+1;
						}
					}
					while(true){
						Switches_Update(switches, switchD, switchDB, switchesPressed, switchCmb, false, noLink);
						Waitframe();
					}
				}
			}
			if(Screen->State[ST_SECRET]){
				for(i=2; i<switches[0]+2; i++){
					Screen->ComboD[switches[i]] = switchCmb+1;
					switchesPressed[i] = true;
				}
				while(true){
					Switches_Update(switches, switchD, switchDB, switchesPressed, switchCmb, false, noLink);
					Waitframe();
				}
			}
		}
		if(pressure){
			while(switches[1]<switches[0]){
				Switches_Update(switches, switchD, switchDB, switchesPressed, switchCmb, true, noLink);
				Waitframe();
			}
			if(id>0){
				if(sfx>0)
					Game->PlaySound(sfx);
				else
					Game->PlaySound(SFX_SECRET);
				for(i=0; i<176; i++){
					if(comboD[i]>0){
						Screen->ComboD[i] = comboD[i]+1;
					}
				}
			}
			else{
				if(sfx>0)
					Game->PlaySound(sfx);
				else
					Game->PlaySound(SFX_SECRET);
				Screen->TriggerSecrets();
			}
			if(perm){
				if(id>0)
					Screen->D[d] |= db;
				else
					Screen->State[ST_SECRET] = true;
			}
		}
		else{
			while(switches[1]<switches[0]){
				Switches_Update(switches, switchD, switchDB, switchesPressed, switchCmb, false, noLink);
				Waitframe();
			}
			if(id>0){
				if(sfx>0)
					Game->PlaySound(sfx);
				else
					Game->PlaySound(SFX_SECRET);
				for(i=0; i<176; i++){
					if(comboD[i]>0){
						Screen->ComboD[i] = comboD[i]+1;
					}
				}
			}
			else{
				if(sfx>0)
					Game->PlaySound(sfx);
				else
					Game->PlaySound(SFX_SECRET);
				Screen->TriggerSecrets();
			}
			if(perm){
				if(id>0)
					Screen->D[d] |= db;
				else
					Screen->State[ST_SECRET] = true;
			}
		}
		while(true){
			Switches_Update(switches, switchD, switchDB, switchesPressed, switchCmb, false, noLink);
			Waitframe();
		}
	}
	void Switches_Update(int switches, int switchD, int switchDB, bool switchesPressed, int switchCmb, bool pressure, bool noLink){
		if(pressure)
			switches[1] = 0;
		for(int i=0; i<switches[0]; i++){
			int j = i+2;
			int k = switches[j];
			int p = Switch_Pressed(ComboX(k), ComboY(k), noLink);
			if(p){
				if(p!=2)
					Screen->ComboD[k] = switchCmb+1;
				if(!switchesPressed[j]){
					Game->PlaySound(SFX_SWITCH_PRESS);
					if(switchD[0]>0){
						Screen->D[switchD[j]] |= switchDB[j];
					}
					switchesPressed[j] = true;
					if(!pressure)
						switches[1]++;
				}
				if(pressure)
					switches[1]++;
			}
			else{
				if(switchesPressed[j]){
					if(pressure){
						Game->PlaySound(SFX_SWITCH_RELEASE);
						Screen->ComboD[k] = switchCmb;
						switchesPressed[j] = false;
					}
					else{
						if(Screen->ComboD[k]!=switchCmb+1)
							Screen->ComboD[k] = switchCmb+1;
					}
				}
			}
		}
	}
}

ffc script Switch_Trap{
	void run(int enemyid, int count){
		while(!Switch_Pressed(this->X, this->Y, false)){
			Waitframe();
		}
		this->Data++;
		Game->PlaySound(SFX_SWITCH_PRESS);
		Game->PlaySound(SFX_SWITCH_ERROR);
		for(int i=0; i<count; i++){
			int pos = Switch_GetSpawnPos();
			npc n = CreateNPCAt(enemyid, ComboX(pos), ComboY(pos));
			Game->PlaySound(SFX_FALL);
			n->Z = 176;
			Waitframes(20);
		}
	}
	int Switch_GetSpawnPos(){
		int pos;
		bool invalid = true;
		int failSafe = 0;
		while(invalid&&failSafe<512){
			pos = Rand(176);
			if(Switch_ValidSpawn(pos))
				return pos;
		}
		for(int i=0; i<176; i++){
			pos = i;
			if(Switch_ValidSpawn(pos))
				return pos;
		}
	}
	bool Switch_ValidSpawn(int pos){
		int x = ComboX(pos);
		int y = ComboY(pos);
		if(Screen->isSolid(x+4, y+4)||
			Screen->isSolid(x+12, y+4)||
			Screen->isSolid(x+4, y+12)||
			Screen->isSolid(x+12, y+12)){
			return false;
		
		}
		if(ComboFI(pos, CF_NOENEMY)||ComboFI(pos, CF_NOGROUNDENEMY))
			return false;
		int ct = Screen->ComboT[pos];
		if(ct==CT_NOENEMY||ct==CT_NOGROUNDENEMY||ct==CT_NOJUMPZONE)
			return false;
		if(ct==CT_WATER||ct==CT_LADDERONLY||ct==CT_HOOKSHOTONLY||ct==CT_LADDERHOOKSHOT)
			return false;
		if(ct==CT_PIT||ct==CT_PITB||ct==CT_PITC||ct==CT_PITD||ct==CT_PITR)
			return false;
		return true;
	}
}

ffc script Switch_Sequential{
	void run(int flag, int perm, int sfx){
		int i; int j; int k;
		int switches[34];
		int switchCmb[34];
		int switchMisc[8];
		bool switchesPressed[34];
		k = SizeOfArray(switches)-2;
		for(i=0; i<176&&switches[0]<k; i++){
			if(Screen->ComboF[i]==flag){
				j = 2+switches[0];
				switches[j] = i;
				switchCmb[j] = Screen->ComboD[i];
				switches[0]++;
			}
		}
		int switchOrder[34];
		Switches_Organize(switches, switchOrder);
		if(perm&&Screen->State[ST_SECRET]){
			for(i=0; i<switches[0]; i++){
				switchesPressed[i+2] = true;
			}
			while(true){
				Switches_Update(switches, switchesPressed, switchOrder, switchCmb, switchMisc, false);
				Waitframe();
			}
		}
		while(switches[1]<switches[0]){
			Switches_Update(switches, switchesPressed, switchOrder, switchCmb, switchMisc, true);
			if(switchMisc[0]==1){
				switchMisc[0] = 0;
				for(i=0; i<30; i++){
					Switches_Update(switches, switchesPressed, switchOrder, switchCmb, switchMisc, false);
					Waitframe();
				}
				while(Switches_LinkOn(switches)){
					Switches_Update(switches, switchesPressed, switchOrder, switchCmb, switchMisc, false);
					Waitframe();
				}
			}
			Waitframe();
		}
		if(sfx>0)
			Game->PlaySound(sfx);
		else
			Game->PlaySound(SFX_SECRET);
		Screen->TriggerSecrets();
		if(perm)
			Screen->State[ST_SECRET] = true;
		for(i=0; i<switches[0]; i++){
			switchesPressed[i+2] = true;
		}
		while(true){
			Switches_Update(switches, switchesPressed, switchOrder, switchCmb, switchMisc, false);
			Waitframe();
		}
		
	}
	void Switches_Organize(int switches, int switchOrder){
		bool banned[34];
		for(int j=0; j<switches[0]; j++){
			int lowest = -1;
			int lowestIndex = -1;
			for(int i=0; i<switches[0]; i++){
				int c = Screen->ComboD[switches[i+2]];
				if(c!=-1&&!banned[i+2]){
					if(lowest==-1||c<lowest){
						lowest = c;
						lowestIndex = i+2;
					}
				}
			}
			switchOrder[j] = lowestIndex;
			banned[lowestIndex] = true;
		}
	}
	bool Switches_LinkOn(int switches){
		for(int i=0; i<switches[0]; i++){
			int j = i+2;
			int k = switches[j];
			int p = Switch_Pressed(ComboX(k), ComboY(k), false);
			if(p==1)
				return true;
		}
		return false;
	}
	void Switches_Update(int switches, bool switchesPressed, int switchOrder, int switchCmb, int switchMisc, bool canPress){
		bool reset;
		for(int i=0; i<switches[0]; i++){
			int j = i+2;
			int k = switches[j];
			int p = Switch_Pressed(ComboX(k), ComboY(k), false);
			if(!switchesPressed[j]){
				if(p!=2)
					Screen->ComboD[k] = switchCmb[j];
				if(p&&canPress){
					if(j==switchOrder[switches[1]]){
						switches[1]++;
						Game->PlaySound(SFX_SWITCH_PRESS);
						switchesPressed[j] = true;
					}
					else{
						switches[1] = 0;
						Game->PlaySound(SFX_SWITCH_ERROR);
						reset = true;
					}
				}
			}
			else{
				if(p!=2)
					Screen->ComboD[k] = switchCmb[j]+1;
				if(p==0&&canPress){
					Game->PlaySound(SFX_SWITCH_RELEASE);
					switchesPressed[j] = false;
				}
			}
		}
		if(reset){
			switchMisc[0] = 1;
			for(int i=0; i<switches[0]; i++){
				int j = i+2;
				int k = switches[j];
				int p = Switch_Pressed(ComboX(k), ComboY(k), false);
				switchesPressed[j] = false;
			}
		}
	}
}

ffc script LttP_Bumper{
	void run(int Bounce){
		int Combo = this->Data;
		int BounceAngle = 0;
		int BounceCounter = 0;
		this->InitD[7] = 0;
		int AnimationCounter = 0;
		int PushX;
		int PushY;
		while(true){
			if(Distance(CenterX(this), CenterY(this), CenterLinkX(), CenterLinkY())<this->TileWidth*8+2&&Link->Z==0){
				if(this->InitD[7]==0){
					Game->PlaySound(SFX_LTTP_BUMPER);
					BounceAngle = Angle(CenterX(this), CenterY(this), CenterLinkX(), CenterLinkY());
					BounceCounter = Bounce;
					AnimationCounter = LTTP_BUMPER_ANIM_SPEED*4;
				}
				NoAction();
			}
			if(BounceCounter>0){
				PushX += VectorX(LTTP_BUMPER_FORCE, BounceAngle);
				PushY += VectorY(LTTP_BUMPER_FORCE, BounceAngle);
				BounceCounter--;
			}
			if(Abs(PushX)>0){
				for(int i=0; i<MAX_PUSH&&PushX<=-1; i++){
					if(CanWalk(Link->X, Link->Y, DIR_LEFT, 1, false)){
						Link->X--;
						PushX++;
					}
					else{
						if(Abs(PushY)>0)
							PushY += Sign(PushY)*Abs(PushX/2);
						PushX = 0;
					}
				}
				for(int i=0; i<MAX_PUSH&&PushX>=1; i++){
					if(CanWalk(Link->X, Link->Y, DIR_RIGHT, 1, false)){
						Link->X++;
						PushX--;
					}
					else{
						if(Abs(PushY)>0)
							PushY += Sign(PushY)*Abs(PushX/2);
						PushX = 0;
					}
				}
			}
			if(Abs(PushY)>0){
				for(int i=0; i<MAX_PUSH&&PushY<=-1; i++){
					if(CanWalk(Link->X, Link->Y, DIR_UP, 1, false)){
						Link->Y--;
						PushY++;
					}
					else{
						if(Abs(PushX)>0)
							PushX += Sign(PushX)*Abs(PushY/2);
						PushY = 0;
					}
				}
				for(int i=0; i<MAX_PUSH&&PushY>=1; i++){
					if(CanWalk(Link->X, Link->Y, DIR_DOWN, 1, false)){
						Link->Y++;
						PushY--;
					}
					else{
						if(Abs(PushX)>0)
							PushX += Sign(PushX)*Abs(PushY/2);
						PushY = 0;
					}
				}
			}
			if(AnimationCounter>0)
				AnimationCounter--;
			this->Data = Combo+Floor(AnimationCounter/LTTP_BUMPER_ANIM_SPEED);
			Waitframe();
		}
	}
}

int MooshPit_OnPit(int LinkX, int LinkY, bool countFFCs){
	if(Link->Action==LA_FROZEN||Link->Action==LA_RAFTING||Link->Action==LA_INWIND)
		return -1;
	
	if(countFFCs){
		if(MooshPit_OnFFC(LinkX, LinkY))
			return -1;
	}
	
	bool sideview;
	if(Screen->Flags[SF_ROOMTYPE]&100b)
		sideview = true;
	//wew lad
	int width = MOOSHPIT_LINKHITBOXWIDTH;
	int height = MOOSHPIT_LINKHITBOXHEIGHT;
	
	int total;
	int solidTotal;
	
	for(int x=0; x<=1; x++){
		for(int y=0; y<=1; y++){
			int X; int Y;
			if(sideview){ //Hitbox functions differently in sideview
				width = MOOSHPIT_SIDEVIEW_LINKHITBOXWIDTH;
				height = MOOSHPIT_SIDEVIEW_LINKHITBOXHEIGHT;
				X = Floor(LinkX+7-width/2+(width-1)*x)+1;
				Y = Floor(LinkY+7-height/2+(height-1)*y)+1;
			}
			else{
				X = Floor(LinkX+7-width/2+(width-1)*x)+1;
				Y = Floor(LinkY+11-height/2+(height-1)*y)+1;
			}
			
			//If one corner of Link's hitbox is on a pit, flag that corner as covered
			if(Screen->ComboT[ComboAt(X, Y)]==CT_HOLELAVA){
				total |= 1<<(1+(x+y*2));
			}
			//If Link is on a solid combo, count that corner as a pit
			if(Screen->isSolid(X, Y)){
				solidTotal |= 1<<(x+y*2);
			}
		}
	}
	if(total>0) //Assuming Link is on at least one actual pit, add up the solid and nonsolid pits
		return (total>>1)|(solidTotal<<4);
	return -1;
}

bool MooshPit_OnFFC(int LinkX, int LinkY){
	for(int i=1; i<=32; i++){ //Cycle through every FFC
		ffc f = Screen->LoadFFC(i);
		//Check if the FFC is solid
		if(f->Data>0&&!f->Flags[FFCF_CHANGER]&&!f->Flags[FFCF_ETHEREAL]){
			//Check if Link collides with the FFC
			if(RectCollision(LinkX+4, LinkY+9, LinkX+11, LinkY+14, f->X, f->Y, f->X+f->EffectWidth-1, f->Y+f->EffectHeight-1)){
				return true;
			}
		}
	}
	//If Link doesn't collide with any FFC, return false
	return false;
}

void MooshPit_StunEnemies(){
	for(int i=Screen->NumNPCs(); i>=1; i--){ //Cycle through every enemy
		npc n = Screen->LoadNPC(i);
		//Make it so the enemy's stun never falls below 1
		n->Stun = Max(n->Stun, 1);
	}
}

void MooshPit_Init(){
	MooshPit[_MP_LASTX] = Link->X;
	MooshPit[_MP_LASTY] = Link->Y;
	MooshPit[_MP_LASTDMAP] = Game->GetCurDMap();
	MooshPit[_MP_LASTSCREEN] = Game->GetCurDMapScreen();
	MooshPit[_MP_ENTRYX] = Link->X;
	MooshPit[_MP_ENTRYY] = Link->Y;
	MooshPit[_MP_ENTRYDMAP] = Game->GetCurDMap();
	MooshPit[_MP_ENTRYSCREEN] = Game->GetCurDMapScreen();
	MooshPit[_MP_FALLSTATE] = 0;
	MooshPit[_MP_FALLTIMER] = 0;
	Link->CollDetection = true;
	Link->Invisible = false;
}

void MooshPit_Update(){
	int i;
	bool isWarp;
	if(Screen->Flags[SF_MISC]&(1<<SF_MISC_MOOSHPITWARP))
		isWarp = true;
	
	bool sideview;
	if(Screen->Flags[SF_ROOMTYPE]&100b)
		sideview = true;
	
	if(Link->Action!=LA_SCROLLING){
		//Update the entry point whenever the screen changes
		if(MooshPit[_MP_ENTRYDMAP]!=Game->GetCurDMap()||MooshPit[_MP_ENTRYSCREEN]!=Game->GetCurDMapScreen()){
			MooshPit[_MP_ENTRYX] = Link->X;
			MooshPit[_MP_ENTRYY] = Link->Y;
			MooshPit[_MP_ENTRYDMAP] = Game->GetCurDMap();
			MooshPit[_MP_ENTRYSCREEN] = Game->GetCurDMapScreen();
		}
		
		if(MooshPit[_MP_FALLSTATE]==0){ //Not falling in pit
			int onPit = MooshPit_OnPit(Link->X, Link->Y, true);
			//Check if slidey pits are enabled and it's not sideview
			if(MOOSHPIT_ENABLE_SLIDEYPITS&&!IsSideview()){
				if(Link->Z<=0&&onPit>-1){ //If Link is partially on a pit
					int slideVx; int slideVy;
					int reps = 1;
					//Check if it's a frame Link should be moved
					if(MooshPit[_MP_SLIDETIMER]%MOOSHPIT_SLIDEYPIT_FREQ==0||MooshPit[_MP_SLIDETIMER]>=MOOSHPIT_SLIDEYPIT_MAXTIME){
						if((onPit&0111b)==0111b){ //Going up-left
							slideVx = -1;
							slideVy = -1;
						}
						else if((onPit&1011b)==1011b){ //Going up-right
							slideVx = 1;
							slideVy = -1;
						}
						else if((onPit&1101b)==1101b){ //Going down-left
							slideVx = -1;
							slideVy = 1;
						}
						else if((onPit&1110b)==1110b){ //Going down-right
							slideVx = 1;
							slideVy = 1;
						}
						else if((onPit&0011b)==0011b){ //Going up
							slideVy = -1;
						}
						else if((onPit&1100b)==1100b){ //Going down
							slideVy = 1;
						}
						else if((onPit&0101b)==0101b){ //Going left
							slideVx = -1;
						}
						else if((onPit&1010b)==1010b){ //Going right
							slideVx = 1;
						}
						else if((onPit&0001b)==0001b){ //Going up-left
							slideVx = -1;
							slideVy = -1;
						}
						else if((onPit&0010b)==0010b){ //Going up-right
							slideVx = 1;
							slideVy = -1;
						}
						else if((onPit&0100b)==0100b){ //Going down-left
							slideVx = -1;
							slideVy = 1;
						}
						else if((onPit&1000b)==1000b){ //Going down-right
							slideVx = 1;
							slideVy = 1;
						}
						
						//DEBUG DRAWS
						//VX
						// Screen->DrawInteger(6, 0, 0, FONT_Z1, 0x01, 0x0F, -1, -1, slideVx, 0, 128);
						//VY
						// Screen->DrawInteger(6, 0, 8, FONT_Z1, 0x01, 0x0F, -1, -1, slideVy, 0, 128);
						//ONPIT BITS
						// Screen->DrawInteger(6, 0, 16, FONT_Z1, 0x01, 0x0F, -1, -1, (onPit&1000b)>>3, 0, 128);
						// Screen->DrawInteger(6, 8, 16, FONT_Z1, 0x01, 0x0F, -1, -1, (onPit&0100b)>>2, 0, 128);
						// Screen->DrawInteger(6, 16, 16, FONT_Z1, 0x01, 0x0F, -1, -1, (onPit&0010b)>>1, 0, 128);
						// Screen->DrawInteger(6, 24, 16, FONT_Z1, 0x01, 0x0F, -1, -1, (onPit&0001b), 0, 128);
						
						//If Link is over the max slide time, increase the speed every 4 frames
						if(MooshPit[_MP_SLIDETIMER]>=MOOSHPIT_SLIDEYPIT_MAXTIME)
							reps += Floor((MooshPit[_MP_SLIDETIMER]-MOOSHPIT_SLIDEYPIT_MAXTIME)/MOOSHPIT_SLIDEYPIT_ACCELFREQ);
					}
					
					for(i=0; i<reps; i++){
						if(slideVx<0&&CanWalk(Link->X, Link->Y, DIR_LEFT, 1, false)){
							Link->X--;
						}
						else if(slideVx>0&&CanWalk(Link->X, Link->Y, DIR_RIGHT, 1, false)){
							Link->X++;
						}
						if(slideVy<0&&CanWalk(Link->X, Link->Y, DIR_UP, 1, false)){
							Link->Y--;
						}
						else if(slideVy>0&&CanWalk(Link->X, Link->Y, DIR_DOWN, 1, false)){
							Link->Y++;
						}
					}
					MooshPit[_MP_SLIDETIMER]++;
				}
				else{
					MooshPit[_MP_SLIDETIMER] = 0;
				}
			}
			if(onPit>-1){
				//Combine solid combo bits with pit bits
				onPit |= (onPit>>4);
				//Remove non pit bits
				onPit &= 1111b;
			}
			if(Link->Z<=0&&onPit==15){ //If Link steps on a pit
				int underLink;
				if(!sideview){
					underLink = ComboAt(Link->X+8, Link->Y+12);
					if(Screen->ComboT[underLink]!=CT_HOLELAVA){
						for(i=0; i<4; i++){
							underLink = ComboAt(Link->X+15*(i%2), Link->Y+8+7*Floor(i/2));
							if(Screen->ComboT[underLink]==CT_HOLELAVA)
								break;
						}
					}
				}
				else{
					underLink = ComboAt(Link->X+8, Link->Y+8);
					if(Screen->ComboT[underLink]!=CT_HOLELAVA){
						for(i=0; i<4; i++){
							underLink = ComboAt(Link->X+15*(i%2), Link->Y+15*Floor(i/2));
							if(Screen->ComboT[underLink]==CT_HOLELAVA)
								break;
						}
					}
				}
			
				lweapon fall;
				
				//Check if the combo is lava
				if(ComboFI(underLink, CF_LAVA)){
					//Play sound and display animation
					Game->PlaySound(SFX_FALLLAVA);
					fall = CreateLWeaponAt(LW_SCRIPT10, Link->X, Link->Y);
					if(!MOOSHPIT_NO_GRID_SNAP){
						fall->X = ComboX(underLink);
						fall->Y = ComboY(underLink);
					}
					fall->UseSprite(SPR_FALLLAVA);
					fall->CollDetection = false;
					fall->DeadState = fall->ASpeed*fall->NumFrames;
				
					//Mark as lava damage
					MooshPit[_MP_DAMAGETYPE] = 1;
				}
				//Otherwise it's a pit
				else{
					//Play sound and display animation
					Game->PlaySound(SFX_FALLHOLE);
					fall = CreateLWeaponAt(LW_SCRIPT10, Link->X, Link->Y);
					if(!MOOSHPIT_NO_GRID_SNAP){
						fall->X = ComboX(underLink);
						fall->Y = ComboY(underLink);
						if(isWarp){
							Link->X = ComboX(underLink);
							Link->Y = ComboY(underLink);
						}
					}
					fall->UseSprite(SPR_FALLHOLE);
					fall->CollDetection = false;
					fall->DeadState = fall->ASpeed*fall->NumFrames;
				
					//Mark as hole damage
					MooshPit[_MP_DAMAGETYPE] = 0;
				}
				
				MooshPit[_MP_FALLX] = Link->X;
				MooshPit[_MP_FALLY] = Link->Y;
				
				//Cooldown should last as long as the fall animation
				MooshPit[_MP_FALLSTATE] = 1;
				MooshPit[_MP_FALLTIMER] = Max(MOOSHPIT_MIN_FALL_TIME, fall->DeadState+MOOSHPIT_EXTRA_FALL_TIME);
				
				//Render Link invisible and intangible
				Link->Invisible = true;
				Link->CollDetection = false;
				
				NoAction();
			}
			else if(MooshPit_OnPit(Link->X, Link->Y, false)==-1&&Link->Action!=LA_FROZEN){ //All other times, while Link is on solid ground, record Link's last position
				if(sideview){
					//Link has no Z value in sideview, so we check if he's on a platform instead
					if(OnSidePlatform(Link->X, Link->Y)){
						MooshPit[_MP_LASTDMAP] = Game->GetCurDMap();
						MooshPit[_MP_LASTSCREEN] = Game->GetCurDMapScreen();
						MooshPit[_MP_LASTX] = Link->X;
						MooshPit[_MP_LASTY] = Link->Y;
					}
				}
				else{
					if(Link->Z<=0){
						MooshPit[_MP_LASTDMAP] = Game->GetCurDMap();
						MooshPit[_MP_LASTSCREEN] = Game->GetCurDMapScreen();
						MooshPit[_MP_LASTX] = Link->X;
						MooshPit[_MP_LASTY] = Link->Y;
					}
				}
			}
		}
		else if(MooshPit[_MP_FALLSTATE]==1){ //Falling animation
			if(MooshPit[_MP_FALLTIMER]>0)
				MooshPit[_MP_FALLTIMER]--;
		
			if(MOOSHPIT_STUN_ENEMIES_WHILE_FALLING)
				MooshPit_StunEnemies();
			
			Link->Jump = 0;
			Link->Z = 0;
			
			//Keep Link invisible just in case
			Link->Invisible = true;
			Link->CollDetection = false;
			NoAction();
			if(MooshPit[_MP_FALLTIMER]==0){
				MooshPit[_MP_SLIDETIMER] = 0;
				if(!isWarp||MooshPit[_MP_DAMAGETYPE]==1){ //If the pit isn't a warp, deal damage and move Link back to the return point
					//If the entry would dump Link back in the pit, dump him out at the failsafe position
					if(MooshPit_OnPit(MooshPit[_MP_ENTRYX], MooshPit[_MP_ENTRYY], false)==15){
						if(MOOSHPIT_NO_REENTER_STAIRS){
							//Call a script to place an FFC under Link to prevent reentering stairs
							int scriptName[] = "MooshPit_StairsFix";
							int ffcNum = RunFFCScript(Game->GetFFCScript(scriptName), 0);
							if(ffcNum>0){
								ffc f = Screen->LoadFFC(ffcNum);
								f->Flags[FFCF_ETHEREAL] = false;
								f->X = MooshPit[_MP_LASTX];
								f->Y = MooshPit[_MP_LASTY];
							}
						}
						
						Link->X = MooshPit[_MP_LASTX];
						Link->Y = MooshPit[_MP_LASTY];
						
						//If the failsafe position was on a different screen, warp there
						if(Game->GetCurDMap()!=MooshPit[_MP_LASTDMAP]||Game->GetCurDMapScreen()!=MooshPit[_MP_LASTSCREEN]){
							Link->PitWarp(MooshPit[_MP_LASTDMAP], MooshPit[_MP_LASTSCREEN]);
						}
				
						Link->Invisible = false;
						Link->CollDetection = true;
					}
					else{
						if(MOOSHPIT_NO_REENTER_STAIRS){
							//Call a script to place an FFC under Link to prevent reentering stairs
							int scriptName[] = "MooshPit_StairsFix";
							int ffcNum = RunFFCScript(Game->GetFFCScript(scriptName), 0);
							if(ffcNum>0){
								ffc f = Screen->LoadFFC(ffcNum);
								f->Flags[FFCF_ETHEREAL] = false;
								f->X = MooshPit[_MP_ENTRYX];
								f->Y = MooshPit[_MP_ENTRYY];
							}
						}
						
						//Move Link to the entry and make him visible
						Link->X = MooshPit[_MP_ENTRYX];
						Link->Y = MooshPit[_MP_ENTRYY];
						
						Link->Invisible = false;
						Link->CollDetection = true;
					}
					
					//Subtract HP based on damage type
					if(MooshPit[_MP_DAMAGETYPE]==1)
						Link->HP -= DAMAGE_FALLLAVA;
					else
						Link->HP -= DAMAGE_FALLHOLE;
					//Play hurt sound and animation
					Link->Action = LA_GOTHURTLAND;
					Link->HitDir = -1;
					Game->PlaySound(SFX_OUCH);
					
					MooshPit[_MP_FALLSTATE] = 0;
				}
				else{
					MooshPit[_MP_FALLSTATE] = 2;
					MooshPit[_MP_FALLTIMER] = 1;
					ffc warp = Screen->LoadFFC(FFC_MOOSHPIT_AUTOWARPA);
					warp->Data = CMB_MOOSHPIT_AUTOWARPA;
					warp->Flags[FFCF_CARRYOVER] = false;
				}
			}
		}
		else if(MooshPit[_MP_FALLSTATE]==2){ //Just warped
			if(sideview){
				Link->X = MooshPit[_MP_FALLX];
				Link->Y = 0;
			}
			else{
				Link->X = MooshPit[_MP_FALLX];
				Link->Y = MooshPit[_MP_FALLY];
				Link->Z = 176;
			}
			Link->Invisible = false;
			Link->CollDetection = true;
			
			if(MOOSHPIT_NO_MOVE_WHILE_FALLING){
				MooshPit[_MP_FALLSTATE] = 3;
				NoAction();
			}
			else
				MooshPit[_MP_FALLSTATE] = 0;
			MooshPit[_MP_FALLTIMER] = 0;
		}
		else if(MooshPit[_MP_FALLSTATE]==3){ //Falling into a new room (no action)
			if(MOOSHPIT_STUN_ENEMIES_WHILE_FALLING)
				MooshPit_StunEnemies();
			
			NoAction();
			if(IsSideview()){
				if(OnSidePlatform(Link->X, Link->Y))
					MooshPit[_MP_FALLSTATE] = 0;
			}
			else{
				if(Link->Z<=0)
					MooshPit[_MP_FALLSTATE] = 0;
			}
		}
	}
}

void MooshPit_ResetEntry(){
	MooshPit[_MP_ENTRYX] = Link->X;
	MooshPit[_MP_ENTRYY] = Link->Y;
	MooshPit[_MP_ENTRYDMAP] = Game->GetCurDMap();
	MooshPit[_MP_ENTRYSCREEN] = Game->GetCurDMapScreen();
}

ffc script MooshPit_StairsFix{
	void run(){
		this->Flags[FFCF_ETHEREAL] = false;
		while(LinkCollision(this)){
			Waitframe();
		}
		this->X = 0;
		this->Y = 0;
		this->Data = 0;
	}
}

ffc script HamiltonianPath{
	void run(int cmbInactive, int cmbActive, int cmbCurrent, int cmbFinished, int perm, int sfx){
		if(sfx==0) //Default secret sound if none specified
			sfx = SFX_SECRET;
		if(perm&&Screen->State[ST_SECRET]){ //If secrets are triggered, set all inactive combos to finished
			for(int i=0; i<176; i++){
				if(Screen->ComboD[i]==cmbInactive||Screen->ComboD[i]==cmbCurrent)
					Screen->ComboD[i] = cmbFinished;
			}
		}
		int currentPos = HamiltonianPath_FindCurrentPos(cmbCurrent);
		int underLinkPos;
		if(currentPos==-1){ //If there is no starting position placed down
			while(currentPos==-1){ //Wait until Link steps on an inactive combo
				underLinkPos = ComboAt(Link->X+8, Link->Y+12);
				if(Screen->ComboD[underLinkPos]==cmbInactive){
					//Set the current position to the inactive combo
					Game->PlaySound(SFX_HAMILTINIAN_PATH);
					currentPos = ComboAt(Link->X+8, Link->Y+12);
					Screen->ComboD[underLinkPos] = cmbCurrent;
				}
				Waitframe();
			}
		}
		int inactiveCombos = 1;
		//Keep running until the script fails to find any inactive combos
		while(inactiveCombos>0){
			underLinkPos = ComboAt(Link->X+8, Link->Y+12);
			if(Screen->ComboD[underLinkPos]==cmbInactive){ //If Link is standing on an inactive combo
				if(underLinkPos==currentPos-1||underLinkPos==currentPos+1||underLinkPos==currentPos-16||underLinkPos==currentPos+16){ //Check if the combo is next to the current one
					Game->PlaySound(SFX_HAMILTINIAN_PATH);
					Screen->ComboD[currentPos] = cmbActive;
					currentPos = underLinkPos;
					Screen->ComboD[currentPos] = cmbCurrent;
				}
			}
			if(Link->Action==LA_FROZEN){ //If Link hookshots to a different combo, update the current position
				int hookshotPos = ComboAt(Link->X+8, Link->Y+12);
				while(Link->Action==LA_FROZEN){
					Waitframe();
				}
				underLinkPos = ComboAt(Link->X+8, Link->Y+12);
				if(currentPos!=underLinkPos&&Screen->ComboD[hookshotPos]==cmbCurrent&&Screen->ComboD[underLinkPos]==cmbInactive){
					Game->PlaySound(SFX_HAMILTINIAN_PATH);
					Screen->ComboD[currentPos] = cmbActive;
					currentPos = underLinkPos;
					Screen->ComboD[currentPos] = cmbCurrent;
				}
			}
			//Count up the remaining inactive combos
			inactiveCombos = 0;
			for(int i=0; i<176; i++){
				if(Screen->ComboD[i]==cmbInactive)
					inactiveCombos++;
			}
			Waitframe();
		}
		for(int i=0; i<176; i++){ //Set all inactive, active, or current combos to finished
			if(Screen->ComboD[i]==cmbInactive||Screen->ComboD[i]==cmbCurrent||Screen->ComboD[i]==cmbActive)
				Screen->ComboD[i] = cmbFinished;
		}
		Game->PlaySound(sfx);
		Screen->TriggerSecrets();
		if(perm)
			Screen->State[ST_SECRET] = true;
	}
	int HamiltonianPath_FindCurrentPos(int cmbCurrent){
		for(int i=0; i<176; i++){
			if(Screen->ComboD[i]==cmbCurrent)
				return i;
		}
		return -1;
	}
}

const int TRAMPOLINE_ANIMATION_FRAMES = 10; //The number of frames the trampoline animates after being jumped on

//Combo Setup:
//Combo 1: Trampoline - Still
//Combo 2: Trampoline - Bouncing
//D0: How high the trampoline launches Link
//D1: The number of the flag marking combos Link can jump over.

ffc script Trampoline{
	bool CanWalkFlag(int flag, int x, int y, int dir, int step, bool full_tile) {
		int c=8;
		int xx = x+15;
		int yy = y+15;
		if(full_tile) c=0;
		if(dir==0) return y-step>0&&(ComboFI(x,y+c-step, flag)||ComboFI(x+8,y+c-step, flag)||ComboFI(xx,y+c-step, flag));
		else if(dir==1) return yy+step<176&&(ComboFI(x,yy+step, flag)||ComboFI(x+8,yy+step, flag)||ComboFI(xx,yy+step, flag));
		else if(dir==2) return x-step>0&&(ComboFI(x-step,y+c, flag)||ComboFI(x-step,y+c+7, flag)||ComboFI(x-step,yy, flag));
		else if(dir==3) return xx+step<256&&(ComboFI(xx+step,y+c, flag)||ComboFI(xx+step,y+c+7, flag)||ComboFI(xx+step,yy, flag));
		return false; //invalid direction
	}
	void run(int JumpHeight, int Flag){
		int Combo = this->Data;
		int OldX;
		int OldY;
		int AnimCounter = 0;
		while(true){
			if(this->Data!=Combo)
				this->Data = Combo;
			if(SquareCollision(Link->X+4, Link->Y+4, 8, this->X+4, this->Y+4, 8)&&Link->Z==0){
				Game->PlaySound(SFX_JUMP);
				Link->Jump = JumpHeight;
				OldX = Link->X;
				OldY = Link->Y;
				this->Data = Combo+1;
				AnimCounter = TRAMPOLINE_ANIMATION_FRAMES;
				do{
					if(AnimCounter>0)	
						AnimCounter--;
					else
						this->Data = Combo;
					bool Moving = false;
					if(Link->InputUp&&(CanWalk(Link->X, Link->Y, DIR_UP, 1.5, false)||CanWalkFlag(Flag, Link->X, Link->Y, DIR_UP, 1.5, false))){
						OldY -= 1.5;
						Moving = true;
					}
					else if(Link->InputDown&&(CanWalk(Link->X, Link->Y, DIR_DOWN, 1.5, false)||CanWalkFlag(Flag, Link->X, Link->Y, DIR_DOWN, 1.5, false))){
						OldY += 1.5;
						Moving = true;
					}
					if(Link->InputLeft&&(CanWalk(Link->X, Link->Y, DIR_LEFT, 1.5, false)||CanWalkFlag(Flag, Link->X, Link->Y, DIR_LEFT, 1.5, false))){
						OldX -= 1.5;
						Moving = true;
					}
					else if(Link->InputRight&&(CanWalk(Link->X, Link->Y, DIR_RIGHT, 1.5, false)||CanWalkFlag(Flag, Link->X, Link->Y, DIR_RIGHT, 1.5, false))){
						OldX += 1.5;
						Moving = true;
					}
					if(Moving){
						Link->X = OldX;
						Link->Y = OldY;
					}
					else{
						OldX = Link->X;
						OldY = Link->Y;
					}
					Waitframe();
				}while(Link->Z>0);
			}
			Waitframe();
		}
	}
}

//Array indices. Don't change.
const int CRSW_FIRSTLOAD = 0;
const int CRSW_ANIM = 1;
const int CRSW_LINKONRAISED = 2;
const int CRSW_LASTDMAP = 3;
const int CRSW_LASTSCREEN = 4;
const int CRSW_JUMPOFF = 5;
const int CRSW_STATICBLOCKANIM = 6;
const int CRSW_LSTATES = 10;
const int CRSW_SCRNDAT = 522;
int CrystalSwitch[698];

void CrystalSwitch_Init(){
	CrystalSwitch[CRSW_ANIM] = 0;
	CrystalSwitch[CRSW_LINKONRAISED] = 0;
	CrystalSwitch[CRSW_JUMPOFF] = 0;
	CrystalSwitch[CRSW_STATICBLOCKANIM] = 0;
	
	int ss[512];
	for(int i=0; i<512; i++)ss[i] = 10101010b; //Crystal switches default to every other color being raised
	
	//%FINDME CrystalSwitch Init States
	//Define special starting states for the levels in your quest here.
	//True = Raised. False = Lowered.
	//                 ss, Level, Color1, Color2, Color3, Color4, Color5, Color6, Color7, Color8
	CS_StartingState(ss, 9,     true,   true,  true);
	
	//Set switch array for the first time the quest is loaded
	if(CrystalSwitch[CRSW_FIRSTLOAD]==0 || CRYSTALSWITCH_RESET_ON_F6){
		for(int i=0; i<512; i++){
			CrystalSwitch[CRSW_LSTATES+i] = ss[i];
		}
		CrystalSwitch[CRSW_FIRSTLOAD] = 1;
	}
}

void CS_StartingState(int startingStates, int levelNum, bool s1up, bool s2up, bool s3up, bool s4up, bool s5up, bool s6up, bool s7up, bool s8up){
	startingStates[levelNum] = 0;
	
	if(s1up)
		startingStates[levelNum] |= 1;
	if(s2up)
		startingStates[levelNum] |= 1<<1;
	if(s3up)
		startingStates[levelNum] |= 1<<2;
	if(s4up)
		startingStates[levelNum] |= 1<<3;
	if(s5up)
		startingStates[levelNum] |= 1<<4;
	if(s6up)
		startingStates[levelNum] |= 1<<5;
	if(s7up)
		startingStates[levelNum] |= 1<<6;
	if(s8up)
		startingStates[levelNum] |= 1<<7;
}
void CS_StartingState(int startingStates, int levelNum, bool s1up, bool s2up, bool s3up, bool s4up, bool s5up, bool s6up, bool s7up){
	startingStates[levelNum] = 0;
	
	if(s1up)
		startingStates[levelNum] |= 1;
	if(s2up)
		startingStates[levelNum] |= 1<<1;
	if(s3up)
		startingStates[levelNum] |= 1<<2;
	if(s4up)
		startingStates[levelNum] |= 1<<3;
	if(s5up)
		startingStates[levelNum] |= 1<<4;
	if(s6up)
		startingStates[levelNum] |= 1<<5;
	if(s7up)
		startingStates[levelNum] |= 1<<6;
}
void CS_StartingState(int startingStates, int levelNum, bool s1up, bool s2up, bool s3up, bool s4up, bool s5up, bool s6up){
	startingStates[levelNum] = 0;
	
	if(s1up)
		startingStates[levelNum] |= 1;
	if(s2up)
		startingStates[levelNum] |= 1<<1;
	if(s3up)
		startingStates[levelNum] |= 1<<2;
	if(s4up)
		startingStates[levelNum] |= 1<<3;
	if(s5up)
		startingStates[levelNum] |= 1<<4;
	if(s6up)
		startingStates[levelNum] |= 1<<5;
}
void CS_StartingState(int startingStates, int levelNum, bool s1up, bool s2up, bool s3up, bool s4up, bool s5up){
	startingStates[levelNum] = 0;
	
	if(s1up)
		startingStates[levelNum] |= 1;
	if(s2up)
		startingStates[levelNum] |= 1<<1;
	if(s3up)
		startingStates[levelNum] |= 1<<2;
	if(s4up)
		startingStates[levelNum] |= 1<<3;
	if(s5up)
		startingStates[levelNum] |= 1<<4;
}
void CS_StartingState(int startingStates, int levelNum, bool s1up, bool s2up, bool s3up, bool s4up){
	startingStates[levelNum] = 0;
	
	if(s1up)
		startingStates[levelNum] |= 1;
	if(s2up)
		startingStates[levelNum] |= 1<<1;
	if(s3up)
		startingStates[levelNum] |= 1<<2;
	if(s4up)
		startingStates[levelNum] |= 1<<3;
}
void CS_StartingState(int startingStates, int levelNum, bool s1up, bool s2up, bool s3up){
	startingStates[levelNum] = 0;
	
	if(s1up)
		startingStates[levelNum] |= 1;
	if(s2up)
		startingStates[levelNum] |= 1<<1;
	if(s3up)
		startingStates[levelNum] |= 1<<2;
}
void CS_StartingState(int startingStates, int levelNum, bool s1up, bool s2up){
	startingStates[levelNum] = 0;
	
	if(s1up)
		startingStates[levelNum] |= 1;
	if(s2up)
		startingStates[levelNum] |= 1<<1;
}

void CrystalSwitch_Update(){
	int i; int j; int k;
	if(Link->Action==LA_SCROLLING){
		//Wipe static block data when scrolling
		for(int i=0; i<176; i++){
			CrystalSwitch[CRSW_SCRNDAT+i] = 0;
		}
	}
	int swCMBOffset;
	if(CRYSTALSWITCH_OFFSET)
		swCMBOffset = CRYSTALSWITCH_OFFSET;
	else
		swCMBOffset = Ceiling((2+CRYSTALSWITCH_RISINGCOMBOS)*0.25)*4;
	int lv = Game->GetCurLevel();
	//TraceBint(6, 0, 0, CrystalSwitch[CRSW_LSTATES+lv]);
	int linkColl = CrystalSwitch_OnRaised(true);
	for(i=0; i<176; i++){
		int cd = Screen->ComboD[i];
		for(j=0; j<CRYSTALSWITCH_NUM_COLORS; j++){
			//Check if each combo is one of the switch combos
			if(cd>=CMB_CRYSTALSWITCH_BLOCKS+swCMBOffset*j&&cd<CMB_CRYSTALSWITCH_BLOCKS+swCMBOffset*j+2+CRYSTALSWITCH_RISINGCOMBOS){
				//Up/Down state of blocks
				int swst = ((CrystalSwitch[CRSW_LSTATES+lv]&(1<<j)))>>j;
				bool animating;
				//Whether blocks are animating
				if(CrystalSwitch[CRSW_ANIM]>0&&CrystalSwitch[CRSW_LSTATES+lv]&(1<<(j+8)))
					animating = true;
				
				//Place the combo based on raising/lowering animation
				if(animating){
					int aframe = Clamp(Floor(CrystalSwitch[CRSW_ANIM]/CRYSTALSWITCH_RISINGASPEED), 0, CRYSTALSWITCH_RISINGCOMBOS-1);
					if(swst){
						aframe = CRYSTALSWITCH_RISINGCOMBOS-1-aframe;
					}
					Screen->ComboD[i] = CMB_CRYSTALSWITCH_BLOCKS+j*swCMBOffset+1+aframe;
				}
				else{
					//Place the raised combo
					if(swst){
						Screen->ComboD[i] = CMB_CRYSTALSWITCH_BLOCKS+j*swCMBOffset+1+CRYSTALSWITCH_RISINGCOMBOS;
					}
					//Place the lowered combo
					else{
						Screen->ComboD[i] = CMB_CRYSTALSWITCH_BLOCKS+j*swCMBOffset;
					}
				}
				
				//If Link can walk on combos, alter the solidity based on that
				if(CRYSTALSWITCH_CAN_WALK_ON_TOP){
					if((!swst&&!animating)||CrystalSwitch[CRSW_LINKONRAISED])
						Screen->ComboS[i] = 0000b;
					else
						Screen->ComboS[i] = 1111b;
				}
			}
		}
		if(cd>=CMB_CRYSTALSWITCH_STATICBLOCKS&&cd<CMB_CRYSTALSWITCH_STATICBLOCKS+2+CRYSTALSWITCH_RISINGCOMBOS){
			int cd2 = cd-CMB_CRYSTALSWITCH_STATICBLOCKS;
			k = (CrystalSwitch[CRSW_SCRNDAT+i]&(0xFF<<8))>>8; //Left 8 bits: Timer. 
			
			if(CRYSTALSWITCH_CAN_WALK_ON_TOP){
				if(linkColl&(1<<9))
					CrystalSwitch[CRSW_LINKONRAISED] = 1;
			}
			
			if(k>0){
				k--;
				if(k==0){
					//Moving Down
					if(CrystalSwitch[CRSW_SCRNDAT+i]&1){
						Screen->ComboD[i] = Clamp(Screen->ComboD[i]-1, CMB_CRYSTALSWITCH_STATICBLOCKS, CMB_CRYSTALSWITCH_STATICBLOCKS+2+CRYSTALSWITCH_RISINGCOMBOS-1);
						if(Screen->ComboD[i]==CMB_CRYSTALSWITCH_STATICBLOCKS){
							k = -1; //Done animating
						}
					}
					//Moving Up
					else{
						Screen->ComboD[i] = Clamp(Screen->ComboD[i]+1, CMB_CRYSTALSWITCH_STATICBLOCKS, CMB_CRYSTALSWITCH_STATICBLOCKS+2+CRYSTALSWITCH_RISINGCOMBOS-1);
						if(Screen->ComboD[i]==CMB_CRYSTALSWITCH_STATICBLOCKS+2+CRYSTALSWITCH_RISINGCOMBOS-1){
							k = -1; //Done animating
						}
					}
					
					if(k==-1){
						k = 0;
					}
					else{
						k = CRYSTALSWITCH_RISINGASPEED;
					}
				}
				CrystalSwitch[CRSW_SCRNDAT+i] &= 0xFF;
				CrystalSwitch[CRSW_SCRNDAT+i] |= k<<8;
			}
			else{
				if(cd2==0){
					CrystalSwitch[CRSW_SCRNDAT+i] &= ~1;
				}
				else if(cd2==2+CRYSTALSWITCH_RISINGCOMBOS-1){
					CrystalSwitch[CRSW_SCRNDAT+i] |= 1;
				}
				else{
					//Moving Down
					if(CrystalSwitch[CRSW_SCRNDAT+i]&1){
						CrystalSwitch[CRSW_SCRNDAT+i] = 1;
						CrystalSwitch[CRSW_SCRNDAT+i] |= CRYSTALSWITCH_RISINGASPEED<<8;
					}
					//Moving Up
					else{
						CrystalSwitch[CRSW_SCRNDAT+i] = 0;
						CrystalSwitch[CRSW_SCRNDAT+i] |= CRYSTALSWITCH_RISINGASPEED<<8;
					}
				}
			}
			
			//If Link can walk on combos, alter the solidity based on that
			if(CRYSTALSWITCH_CAN_WALK_ON_TOP){
				if(linkColl&(1<<9))
					CrystalSwitch[CRSW_LINKONRAISED] = 1;
				if(cd2==0||CrystalSwitch[CRSW_LINKONRAISED])
					Screen->ComboS[i] = 0000b;
				else
					Screen->ComboS[i] = 1111b;
			}
		}
	}
	
	if(CRYSTALSWITCH_CAN_WALK_ON_TOP){
		if(Link->Action!=LA_SCROLLING&&!IsSideview()){
			//When entering a screen on a raised block
			if(Game->GetCurDMap()!=CrystalSwitch[CRSW_LASTDMAP]||Game->GetCurDMapScreen()!=CrystalSwitch[CRSW_LASTSCREEN]){
				if(CrystalSwitch_OnRaised(true)){
					CrystalSwitch[CRSW_LINKONRAISED] = 1;
				}
				CrystalSwitch[CRSW_LASTDMAP] = Game->GetCurDMap();
				CrystalSwitch[CRSW_LASTSCREEN] = Game->GetCurDMapScreen();
			}
			//Else detect Link stepping off a block
			else if(CrystalSwitch[CRSW_LINKONRAISED]){
				if(Link->Z==0&&Link->Action!=LA_FROZEN&&!CrystalSwitch_OnRaised(true)){
					Game->PlaySound(SFX_JUMP);
					Link->Jump = 1;
					Link->Z = 4;
					CrystalSwitch[CRSW_JUMPOFF] = 1;
					CrystalSwitch[CRSW_LINKONRAISED] = 0;
				}
				//If he's not stepping off but the block is animating, move him with it
				else if(CRYSTALSWITCH_RAISELINK){
					if(CrystalSwitch[CRSW_ANIM]>0&&!IsSideview()){
						linkColl = CrystalSwitch_OnRaised(false);
						int movement = -1;
						//Find the sum of movement up/down of the blocks Link is standing on
						for(j=0; j<CRYSTALSWITCH_NUM_COLORS; j++){
							//Check if Link is touching the block
							if(linkColl&(1<<j)){
								//Raised block
								if(CrystalSwitch[CRSW_LSTATES+Game->GetCurLevel()]&(1<<j)){
									//Is it currently animating?
									if(CrystalSwitch[CRSW_LSTATES+Game->GetCurLevel()]&(1<<(j+8))){
										if(movement==-1)
											movement = 2;
										//Cancel out conflicting movements
										else if(movement==1)
											movement = 0;
									}
									//Link is on an unmoving raised block and cannot be affected by others
									else{
										movement = 0;
									}
								}
								//Lowered block
								else{
									//Is it currently animating?
									if(CrystalSwitch[CRSW_LSTATES+Game->GetCurLevel()]&(1<<(j+8))){
										if(movement==-1)
											movement = 1;
										//Cancel out conflicting movements
										else if(movement==2)
											movement = 0;
									}
								}
							}
						}
						if(movement==-1)
							movement = 0;
						if(movement>0){
							j = CrystalSwitch[CRSW_ANIM]/(CRYSTALSWITCH_RISINGASPEED*CRYSTALSWITCH_RISINGCOMBOS)*CRYSTALSWITCH_RAISELINK;
							k = Min(CrystalSwitch[CRSW_ANIM]+1, (CRYSTALSWITCH_RISINGASPEED*CRYSTALSWITCH_RISINGCOMBOS))/(CRYSTALSWITCH_RISINGASPEED*CRYSTALSWITCH_RISINGCOMBOS)*CRYSTALSWITCH_RAISELINK;
							
							j = Abs(Round(j)-Round(k));
							for(i=0; i<j; i++){
								if(movement==2){
									if(CanWalk(Link->X, Link->Y, DIR_UP, 1, false)){
										Link->Y--;
										if(!CrystalSwitch_OnRaised(true))
											Link->Y++;
									}
								}
								else{
									if(CanWalk(Link->X, Link->Y, DIR_DOWN, 1, false)){
										Link->Y++;
										if(!CrystalSwitch_OnRaised(true))
											Link->Y--;
									}
								}
							}
						}
					}
				}
			}
		}
		else
			CrystalSwitch[CRSW_LINKONRAISED] = 0;
	}
	
	//Prevent movement while jumping off a block
	if(CrystalSwitch[CRSW_JUMPOFF]){
		if(Link->Z>0)
			NoAction();
		else
			CrystalSwitch[CRSW_JUMPOFF] = 0;
	}
	
	if(CrystalSwitch[CRSW_ANIM]>0)
		CrystalSwitch[CRSW_ANIM]--;
	else{
		CrystalSwitch[CRSW_LSTATES+Game->GetCurLevel()] &= 0xFF;
	}
}

//Return sum of all bits for blocks Link is standing on
int CrystalSwitch_OnRaised(bool onlyRaised){
	int swCMBOffset;
	if(CRYSTALSWITCH_OFFSET)
		swCMBOffset = CRYSTALSWITCH_OFFSET;
	else
		swCMBOffset = Ceiling((2+CRYSTALSWITCH_RISINGCOMBOS)*0.25)*4;
	int ret;
	bool blockLowering;
	for(int x=0; x<2; x++){
		for(int y=0; y<2; y++){
			int cd = Screen->ComboD[ComboAt(Link->X+2+x*12, Link->Y+10+y*4)];
			//Check if Link is on colored blocks
			for(int j=0; j<CRYSTALSWITCH_NUM_COLORS; j++){
				if(cd>=CMB_CRYSTALSWITCH_BLOCKS+swCMBOffset*j&&cd<CMB_CRYSTALSWITCH_BLOCKS+swCMBOffset*j+2+CRYSTALSWITCH_RISINGCOMBOS){
					if(onlyRaised){
						int lstate = CrystalSwitch[CRSW_LSTATES+Game->GetCurLevel()];
						//Animated combos
						if(lstate&(1<<(j+8))){
							//Lowered, raising
							if(lstate&(1<<j)){
								ret |= (1<<j);
							}
							//Raised, lowering, last frame
							else if(CrystalSwitch[CRSW_LINKONRAISED]&&CrystalSwitch[CRSW_ANIM]==1){
								blockLowering = true;
							}
							else{
								ret |= (1<<j);
							}
								
						}
						else if(lstate&(1<<j)){
							ret |= (1<<j);
						}
					}
					else{
						ret |= (1<<j);
					}
				}
			}
			//Check if Link is on gray blocks
			if(cd>=CMB_CRYSTALSWITCH_STATICBLOCKS&&cd<CMB_CRYSTALSWITCH_STATICBLOCKS+2+CRYSTALSWITCH_RISINGCOMBOS){
				int cd2 = cd-CMB_CRYSTALSWITCH_STATICBLOCKS;
				if(onlyRaised){
					if(cd2==0){
						//blockLowering = true;
					}
					else{
						ret |= 1<<9;
					}
				}
				else{
					ret |= (1<<9);
				}
			}
		}
	}
	
	//Unset on block variable if Link is standing on a block during its last lowering frame
	if(ret==0&&blockLowering){
		CrystalSwitch[CRSW_LINKONRAISED] = 0;
		return 1<<15; //Return a value just to prevent the hopping code from running. 
	}
	return ret;
}

//D0-D3: Switch colors (1-8) to toggle. 0 for none.
//D6: If >0, forces the switch to use a custom pair of combos. Based on the state of D0. Raised combo, followed by lowered.
//D7: Special behaviors
//		0 - Standard operations. D0-D4 toggle between lowered and raised.
//		1 - Lower D0, raise all others
//		2 - Cycle between lowered color, raise all others
ffc script CrystalSwitch_Trigger{
	void run(int toggleA, int toggleB, int toggleC, int toggleD, int d4, int d5, int forceCombo, int specialBehavior){
		if(toggleA==toggleB){
			if(toggleA==0&&toggleB==0){
				toggleA = 1;
				toggleB = 2;
			}
			else
				toggleB = toggleA+1;
		}
		if(toggleA>0)
			toggleA = Clamp(toggleA-1, 0, CRYSTALSWITCH_NUM_COLORS-1);
		else
			toggleA = -1;
		if(toggleB>0)
			toggleB = Clamp(toggleB-1, 0, CRYSTALSWITCH_NUM_COLORS-1);
		else
			toggleB = -1;
		if(toggleC>0)
			toggleC = Clamp(toggleC-1, 0, CRYSTALSWITCH_NUM_COLORS-1);
		else
			toggleC = -1;
		if(toggleD>0)
			toggleD = Clamp(toggleD-1, 0, CRYSTALSWITCH_NUM_COLORS-1);
		else
			toggleD = -1;
		
		int toggleCount;
		if(toggleA>-1)
			toggleCount++;
		if(toggleB>-1)
			toggleCount++;
		if(toggleC>-1)
			toggleCount++;
		if(toggleD>-1)
			toggleCount++;
		
		
		int pos = ComboAt(this->X+8, this->Y+8);
		this->X = ComboX(pos);
		this->Y = ComboY(pos);
		
		lweapon lastTrigger[1];
		this->Data = 0;
		
		int strikeCooldown;
		while(true){
			int lstate = CrystalSwitch[CRSW_LSTATES+Game->GetCurLevel()];
			
			int loweredState = -1;
			//Find the first state that's lowered
			if(loweredState==-1){
				if(!(lstate&(1<<toggleA)))
					loweredState = toggleA;
			}
			if(loweredState==-1){
				if(!(lstate&(1<<toggleB)))
					loweredState = toggleB;
			}
			if(loweredState==-1){
				if(!(lstate&(1<<toggleC)))
					loweredState = toggleC;
			}
			if(loweredState==-1){
				if(!(lstate&(1<<toggleD)))
					loweredState = toggleD;
			}
			
			bool canHit = true;
			//In Special Behavior 1: The switch cannot be hit if A is already lowered
			if(specialBehavior==1&&!(lstate&(1<<toggleA)))
				canHit = false;
			if(CrystalSwitch_CheckCollision(this, lastTrigger)){
				if(strikeCooldown==0&&canHit&&CrystalSwitch[CRSW_ANIM]==0){
					Game->PlaySound(SFX_CRYSTALSWITCH_TRIGGER);
					
					int linkColl = CrystalSwitch_OnRaised(false)&0xFF; //Function returns sum of all bits for blocks Link is on
					
					int newState = 0; //Flag which block states are being changed
					int newStateMask = 0; //Mask used for combining new states with the existing level states
					
					//Raise all, lower A
					if(specialBehavior==1){
						newStateMask |= 1<<toggleA;
						if(toggleB>-1){
							newState |= 1<<toggleB;
							newStateMask |= 1<<toggleB;
						}
						if(toggleC>-1){
							newState |= 1<<toggleC;
							newStateMask |= 1<<toggleC;
						}
						if(toggleD>-1){
							newState |= 1<<toggleD;
							newStateMask |= 1<<toggleD;
						}
					}
					//Alternate A-D lowered
					else if(specialBehavior==2){
						int nextState = toggleA;
						if(loweredState==toggleA){
							if(toggleB>-1)
								nextState = toggleB;
							else if(toggleC>-1)
								nextState = toggleC;
							else if(toggleD>-1)
								nextState = toggleD;
						}
						if(loweredState==toggleB){
							if(toggleC>-1)
								nextState = toggleC;
							else if(toggleD>-1)
								nextState = toggleD;
							else if(toggleA>-1)
								nextState = toggleA;
						}
						if(loweredState==toggleC){
							if(toggleD>-1)
								nextState = toggleD;
							else if(toggleA>-1)
								nextState = toggleA;
							else if(toggleB>-1)
								nextState = toggleB;
						}
						if(loweredState==toggleD){
							if(toggleA>-1)
								nextState = toggleA;
							else if(toggleB>-1)
								nextState = toggleB;
							else if(toggleC>-1)
								nextState = toggleC;
						}
						
						if(toggleA>-1){
							newState |= 1<<toggleA;
							newStateMask |= 1<<toggleA;
						}
						if(toggleB>-1){
							newState |= 1<<toggleB;
							newStateMask |= 1<<toggleB;
						}
						if(toggleC>-1){
							newState |= 1<<toggleC;
							newStateMask |= 1<<toggleC;
						}
						if(toggleD>-1){
							newState |= 1<<toggleD;
							newStateMask |= 1<<toggleD;
						}
						
						newState &= ~(1<<nextState);
					}
					//Toggle all
					else{
						if(toggleA>-1){
							if(!(lstate&(1<<toggleA)))
								newState |= 1<<toggleA;
							newStateMask |= 1<<toggleA;
						}
						if(toggleB>-1){
							if(!(lstate&(1<<toggleB)))
								newState |= 1<<toggleB;
							newStateMask |= 1<<toggleB;
						}
						if(toggleC>-1){
							if(!(lstate&(1<<toggleC)))
								newState |= 1<<toggleC;
							newStateMask |= 1<<toggleC;
						}
						if(toggleD>-1){
							if(!(lstate&(1<<toggleD)))
								newState |= 1<<toggleD;
							newStateMask |= 1<<toggleD;
						}
					}
					
					if(CRYSTALSWITCH_CAN_WALK_ON_TOP){
						if(!IsSideview()&&(linkColl&newState)){
							CrystalSwitch[CRSW_LINKONRAISED] = 1;
						}
					}
					
					int astate = (((lstate&0xFF)^newState)&newStateMask)<<8; //Find bits that have changed to determine which combos should animate
					
					lstate &= ~newStateMask; //Unset bits affected by new state
					lstate |= newState; //Combine new state with the current one
					
					lstate &= 0xFF; //Clear old animation data
					lstate |= astate; //Set new animation bits
					
					CrystalSwitch[CRSW_LSTATES+Game->GetCurLevel()] = lstate;
					
					CrystalSwitch[CRSW_ANIM] = CRYSTALSWITCH_RISINGCOMBOS*CRYSTALSWITCH_RISINGASPEED;
					strikeCooldown = 20;
				}
			}
			
			int switchColor = 0;
			if(loweredState>-1)
				switchColor = 4+loweredState*2;
			if(specialBehavior==1){
				if(lstate&(1<<toggleA))
					switchColor = 4+toggleA*2;
				else
					switchColor = 4+toggleA*2+1;
			}
			if(toggleCount>2){
				if(specialBehavior==0&&CRYSTALSWITCH_USE_BLANK_TRIGGER){
					if(lstate&(1<<toggleA))
						switchColor = 1;
					else
						switchColor = 0;
				} 
			}
			
			int switchCMB = CMB_CRYSTALSWITCH_TRIGGERS+switchColor;
			if(forceCombo){
				if(lstate&(1<<toggleA))
					switchCMB = forceCombo+1;
				else
					switchCMB = forceCombo;
			}
			
			if(CRYSTALSWITCH_USE_FFC_GRAPHICS)
				this->Data = switchCMB;
			else
				Screen->ComboD[pos] = switchCMB;
			
			if(strikeCooldown>0)
				strikeCooldown--;
			Waitframe();
		}
	}
	bool CrystalSwitch_CheckCollision(ffc this, lweapon lastTrigger){
		bool excludedTypes[41];
		//Define all weapon types that can't hit the switch here
		excludedTypes[LW_CANEOFBYRNA] = true;
		excludedTypes[LW_BOMB] = true;
		excludedTypes[LW_SBOMB] = true;
		excludedTypes[LW_FIRE] = true;
		excludedTypes[LW_WHISTLE] = true;
		excludedTypes[LW_BAIT] = true;
		excludedTypes[LW_MAGIC] = true;
		excludedTypes[LW_WIND] = true;
		excludedTypes[LW_REFMAGIC] = true;
		excludedTypes[LW_REFFIREBALL] = true;
		excludedTypes[LW_SPARKLE] = true;
		excludedTypes[LW_FIRESPARKLE] = true;
		
		for(int i=Screen->NumLWeapons(); i>=1; i--){
			lweapon l = Screen->LoadLWeapon(i);
			if(l!=lastTrigger[0]){
				if(!excludedTypes[l->ID]&&l->CollDetection&&l->DeadState==WDS_ALIVE){
					if(Collision(this, l)){
						lastTrigger[0] = l;
						if(l->ID==LW_BRANG||l->ID==LW_HOOKSHOT)
							l->DeadState = WDS_BOUNCE;
						else if(l->ID==LW_ARROW)
							l->DeadState = WDS_ARROW;
						else if(l->ID==LW_BEAM)
							l->DeadState = WDS_BEAMSHARDS;
						else if(l->ID==LW_MAGIC||l->ID==LW_REFMAGIC||l->ID==LW_REFROCK||l->ID==LW_REFFIREBALL)
							l->DeadState = 0;
						return true;
					}
				}
			}
		}
	}
}

const int SFX_LIGHTPANEL_TURN = 51; //Sound when a light panel turns

ffc script LightPath{
	void run(int cmbNode, int cmbRotatepath, int cmbFloorPath, int sfx){
		bool alreadyTriggered;
		if(Screen->State[ST_SECRET])
			alreadyTriggered = true;
		if(sfx==0)
			sfx = 27;
		int mainState[176]; //The type of each combo
		int dirState[176]; //Binary flag for the four directions of the combo
		int active[176]; //Whether or not the combo is activated
		int rotTime[176]; //Timer for rotating panels
		//First we cycle through every combo on the screen and
		//assign it a type based on ComboD.
		for(int i=0; i<176; i++){
			int cd = Screen->ComboD[i];
			if(cd>=cmbFloorPath&&cd<=cmbFloorPath+31){
				mainState[i] = 1; //Fixed Path
				dirState[i] = (cd-cmbFloorPath)%16;
			}
			else if(cd>=cmbRotatepath&&cd<=cmbRotatepath+31){
				mainState[i] = 2; //Rotating Path
				dirState[i] = (cd-cmbRotatepath)%16;
			}
			else if(cd>=cmbNode&&cd<=cmbNode+15){
				mainState[i] = 3; //Trigger Node
				dirState[i] = (cd-cmbNode)%16;
			}
			else if(cd>=cmbNode+16&&cd<=cmbNode+31){
				mainState[i] = 4; //Source Node
				dirState[i] = (cd-cmbNode+16)%16;
			}
		}
		int vars[16] = {1, cmbNode, cmbRotatepath, cmbFloorPath};
		
		//Update the path for the start of the puzzle
		LightPath_UpdatePath(mainState, dirState, active);
		while(true){
			//If there's no active nodes left and the puzzle hasn't already been
			//solved, play the chime and solve it.
			if(vars[0]<=0&&!alreadyTriggered){
				alreadyTriggered = true;
				Game->PlaySound(sfx);
				Screen->TriggerSecrets();
				Screen->State[ST_SECRET] = true;
			}
			//Keep the combos up to date and keep track of active nodes
			LightPath_UpdateCombos(vars, mainState, dirState, active, rotTime);
			Waitframe();
		}
	}
	//Finds the combo next to another combo
	int LightPath_AdjacentPos(int pos, int dir){
		if(dir==DIR_UP){
			if(pos<16)
				return -1;
			return pos-16;
		}
		if(dir==DIR_DOWN){
			if(pos>159)
				return -1;
			return pos+16;
		}
		if(dir==DIR_LEFT){
			if(pos%16==0)
				return -1;
			return pos-1;
		}
		if(dir==DIR_RIGHT){
			if(pos%16==15)
				return -1;
			return pos+1;
		}
	}
	//Finds the next direction in a node with two or less directions
	int LightPath_FindNextDir(int node, int dirState, int lastDir){
		for(int i=0; i<4; i++){
			if(i!=OppositeDir(lastDir)){
				if(dirState[node]&(1<<i)){
					return i;
				}
			}
		}
		return lastDir;
	}
	//Rotate a panel's directions clockwise
	void LightPath_Rotate(int node, int dirState){
		int newState;
		if(dirState[node]&(1<<DIR_UP))
			newState |= (1<<DIR_RIGHT);
		if(dirState[node]&(1<<DIR_RIGHT))
			newState |= (1<<DIR_DOWN);
		if(dirState[node]&(1<<DIR_DOWN))
			newState |= (1<<DIR_LEFT);
		if(dirState[node]&(1<<DIR_LEFT))
			newState |= (1<<DIR_UP);
		dirState[node] = newState;
	}
	//Find a panel combo under a sword weapon
	int LightPath_SwordCombo(lweapon sword, int mainState){
		//A charged sword doesn't flip panels
		if(Link->Action==LA_CHARGING)
			return -1;
		//Only flip panels when the sword is held in front of Link
		if((Link->Dir==DIR_UP||Link->Dir==DIR_DOWN)&&Abs(sword->X-Link->X)>4)
			return -1;
		if((Link->Dir==DIR_LEFT||Link->Dir==DIR_RIGHT)&&Abs(sword->Y-Link->Y)>4)
			return -1;
		int uc = ComboAt(sword->X+8, sword->Y+8);
		if(mainState[uc]==2)
			return uc;
		for(int x=0; x<2; x++){
			for(int y=0; y<2; y++){
				uc = ComboAt(sword->X+6+x*3, sword->Y+6+y*3);
				if(mainState[uc]==2)
					return uc;
			}
		}
		return -1;
	}
	//Run the light path from a branching node until it hits a dead end
	//or runs through all directions.
	void LightPath_RunFromNode(int node, int mainState, int dirState, int active){
		int nextPos;
		for(int i=0; i<4; i++){ //Run through all directions
			if(dirState[node]&(1<<i)){ //If that direction is valid
				nextPos = LightPath_AdjacentPos(node, i);
				int dir = i;
				while(!active[nextPos]&&dirState[nextPos]&(1<<OppositeDir(dir))){
					active[nextPos] = 1;
					if(dirState[nextPos]==1111b||dirState[nextPos]==0111b||dirState[nextPos]==1011b||dirState[nextPos]==1101b||dirState[nextPos]==1110b){
						//You play a dangerous game there, Moosh...
						//Working with powers beyond your understanding...
						//Will ZScript break under the strain of the recursive functions?
						//Only time will tell...
						LightPath_RunFromNode(nextPos, mainState, dirState, active);
						break;
					}
					dir = LightPath_FindNextDir(nextPos, dirState, dir);
					nextPos = LightPath_AdjacentPos(nextPos, dir);
					if(nextPos==-1) //If it goes off the screen, break out
						break;
				}
			}
		}
	}
	//Update the entire path
	void LightPath_UpdatePath(int mainState, int dirState, int active){
		//Cycle through an deactivate all nodes but the start
		for(int i=0; i<176; i++){
			if(mainState[i]!=4) //Don't deactivate source nodes
				active[i] = 0;
		}
		//Cycle to any start nodes and run from there
		for(int i=0; i<176; i++){
			if(mainState[i]==4){ //Source Node
				LightPath_RunFromNode(i, mainState, dirState, active);
			}
		}
	}
	//Set combo GFX and keep track of if the puzzle has been solved
	void LightPath_UpdateCombos(int vars, int mainState, int dirState, int active, int rotTime){
		vars[0] = 0;
		//Detect the sword collision
		lweapon sword = LoadLWeaponOf(LW_SWORD);
		if(sword->isValid()){
			int pos = LightPath_SwordCombo(sword, mainState);
			if(pos>-1){ //Rotating path
				if(Distance(Link->X, Link->Y, sword->X, sword->Y)>10){
					if(rotTime[pos]==0){
						Game->PlaySound(SFX_LIGHTPANEL_TURN);
						rotTime[pos] = 1;
					}
				}
			}
		}
		for(int i=0; i<176; i++){
			if(mainState[i]==1){ //Fixed Path
				Screen->ComboD[i] = vars[3]+dirState[i]+16*active[i];
			}
			if(mainState[i]==2){ //Rotating Path
				Screen->ComboD[i] = vars[2]+dirState[i]+16*active[i];
				if(rotTime[i]>0){
					Screen->FastCombo(2, ComboX(i), ComboY(i), Screen->UnderCombo, Screen->UnderCSet, 128);
					Screen->DrawCombo(2, ComboX(i), ComboY(i), Screen->ComboD[i], 1, 1, Screen->ComboC[i], -1, -1, ComboX(i), ComboY(i), rotTime[i]*6, -1, 0, true, 128);
					rotTime[i]++;
					if(rotTime[i]>=15){
						rotTime[i] = 0;
						LightPath_Rotate(i, dirState);
						LightPath_UpdatePath(mainState, dirState, active);
						//A weird bug happened here, so I added this hack fix
						//to ensure the puzzle can't be solved on the same frame
						//as a panel was flipped.
						vars[0] = 1;
					}
				}
			}
			else if(mainState[i]==3){ //Trigger Node
				if(!active[i])
					vars[0]++;
				Screen->ComboD[i] = vars[1]+dirState[i]+16*active[i];
			}
		}
	}
}

//LttP Beamos Script
//Attribute 1: The starting angle of the eye in degrees.
//Attribute 2: How fast the eye turns each frame in degrees. Make negative for a counterclockwise turn.
//Attribute 3: How long the enemy waits before it can fire another laser in frames. (60ths of a second)
//Attribute 4: Whether or not the enemy has collision. 0 = Yes, 1 = No. No collision is mostly for placing over a solid combo.
//Attribute 11: The first of 10 combos. Statue top, statue bottom, eye up, eye down, eye left, eye right, eye left-up, eye right-up, eye left-down, eye right-down
//Attribute 12: The slot this script is loaded into

ffc script Beamos{
	//This function draws the parts of the beamos in the right order
	void Beamos_Draw(ffc this, npc ghost, int Combo, int EyeAngle){
		int EyeX = Ghost_X+VectorX(8, EyeAngle);
		int EyeY = Ghost_Y+4+VectorY(5, EyeAngle);
		int EyeCombo = Combo+2+AngleDir8(EyeAngle);
		if(Link->HP>0){
			if(EyeAngle<=0)
				Screen->FastCombo(LAYER_BEAMOS2, EyeX, EyeY, EyeCombo, this->CSet, 128);
			Screen->FastCombo(LAYER_BEAMOS2, Ghost_X, Ghost_Y, Combo, this->CSet, 128);
			if(EyeAngle>0)
				Screen->FastCombo(LAYER_BEAMOS2, EyeX, EyeY, EyeCombo, this->CSet, 128);
			Screen->FastCombo(LAYER_BEAMOS1, Ghost_X, Ghost_Y+16, Combo+1, this->CSet, 128);
		}
	}
	//This function checks the path of the beamos' laser before firing
	bool CheckPath(int X, int Y, int Angle, int Distance, int SafeDist, int Step){
		for(int i = 0; i<Distance-Step; i+=Step){
			X += VectorX(Step, Angle);
			Y += VectorY(Step, Angle);
			if(Screen->isSolid(X, Y)&&i>SafeDist)
				return false;
		}
		return true;
	}
	//This function checks if the laser is colliding with Link and deals damage
	void CheckBeamosLaser(npc ghost, int StartX, int StartY, int EndX, int EndY){
		if(lineBoxCollision(StartX, StartY, EndX, EndY, Link->X, Link->Y, Link->X+Link->HitWidth, Link->Y+Link->HitHeight, 0)){
			eweapon e = FireEWeapon(EW_SCRIPT10, Link->X+InFrontX(Link->Dir, 10), Link->Y+InFrontY(Link->Dir, 10), 0, 0, ghost->WeaponDamage, -1, -1, EWF_UNBLOCKABLE);
			SetEWeaponLifespan(e, EWL_TIMER, 1);
			SetEWeaponDeathEffect(e, EWD_VANISH, 0);
			e->DrawYOffset = -1000;
		}
	}
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		int StartAngle = ghost->Attributes[0];
		int IncrementAngle = ghost->Attributes[1];
		int LaserCooldown = ghost->Attributes[2];
		int NoCollision = ghost->Attributes[3];
		int Combo = ghost->Attributes[10];
		Ghost_Transform(this, ghost, GH_INVISIBLE_COMBO, ghost->CSet, 1, 2);
		Ghost_Y-=8;
		if(NoCollision==1)
			ghost->CollDetection = false;
		Ghost_SetHitOffsets(ghost, 16, 0, 0, 0);
		int EyeAngle = WrapDegrees(StartAngle);
		this->Flags[FFCF_IGNOREHOLDUP] = true;
		while(true){
			EyeAngle = WrapDegrees(EyeAngle+IncrementAngle);
			int EyeX = Ghost_X+VectorX(8, EyeAngle);
			int EyeY = Ghost_Y+4+VectorY(5, EyeAngle);
			int AngleLink = Angle(EyeX+8, EyeY+8, CenterLinkX(), CenterLinkY());
			int DistLink = Distance(EyeX+8, EyeY+8, CenterLinkX(), CenterLinkY());
			//Check if the eye is aimed at Link and there's a clear path before firing
			if(Abs(angleDifference(EyeAngle, AngleLink))<BEAMOS_IMPRECISION&&CheckPath(EyeX+8, EyeY+8, AngleLink, DistLink, BEAMOS_LASER_MINDIST, 6)){
				int Angle = Angle(Ghost_X+8, Ghost_Y+8, CenterLinkX(), CenterLinkY());
				int LStartX = EyeX+8;
				int LStartY = EyeY+8;
				int LEndX = LStartX;
				int LEndY = LStartY;
				int LaserLength = 0;
				bool LaserEnded = false;
				//Play the line of sight sound and flash briefly
				Game->PlaySound(SFX_BEAMOS_SIGHT);
				Ghost_StartFlashing(BEAMOS_FLASHFRAMES);
				for(int i=0; i<BEAMOS_FLASHFRAMES; i++){
					Beamos_Draw(this, ghost, Combo, EyeAngle);
					Ghost_Waitframe(this, ghost, true, true);
				}
				//Fire the laser until it reaches full length or hits a wall
				Game->PlaySound(SFX_BEAMOS_LASER);
				while(Distance(LStartX, LStartY, LEndX, LEndY)<BEAMOS_LASER_LENGTH&&!LaserEnded){
					int LDist = Distance(LStartX, LStartY, LEndX, LEndY);
					LEndX += VectorX(BEAMOS_LASER_SPEED, Angle);
					LEndY += VectorY(BEAMOS_LASER_SPEED, Angle);
					LaserLength += BEAMOS_LASER_SPEED;
					if((Screen->isSolid(LEndX, LEndY)&&Distance(EyeX+8, EyeY+8, LEndX, LEndY)>=BEAMOS_LASER_MINDIST)||(LEndX<-16||LEndX>272||LEndY<-16||LEndY>192))
						LaserEnded = true;
					//Draw everything in order
					int EyeCombo = Combo+2+AngleDir8(EyeAngle);
					if(Link->HP>0){
						if(EyeAngle<=0){
							Screen->FastCombo(LAYER_BEAMOS2, EyeX, EyeY, EyeCombo, this->CSet, 128);
							Screen->Rectangle(LAYER_BEAMOS2, LStartX, LStartY-1, LStartX+LDist, LStartY+1, COLOR_BEAMOS_LASER2, 1, LStartX, LStartY, Angle, true, 128);
							Screen->Line(LAYER_BEAMOS2, LStartX, LStartY, LEndX, LEndY, COLOR_BEAMOS_LASER1, 1, 0, 0, 0, 128);
							Screen->FastCombo(LAYER_BEAMOS2, LStartX-8, LStartY-8, CMB_BEAMOS_LASER_ENDPOINT, CS_BEAMOS_LASER_ENDPOINT, 128);
						}
						Screen->FastCombo(LAYER_BEAMOS2, Ghost_X, Ghost_Y, Combo, this->CSet, 128);
						if(EyeAngle>0){
							Screen->FastCombo(LAYER_BEAMOS2, EyeX, EyeY, EyeCombo, this->CSet, 128);
							Screen->Rectangle(LAYER_BEAMOS2, LStartX, LStartY-1, LStartX+LDist, LStartY+1, COLOR_BEAMOS_LASER2, 1, LStartX, LStartY, Angle, true, 128);
							Screen->Line(LAYER_BEAMOS2, LStartX, LStartY, LEndX, LEndY, COLOR_BEAMOS_LASER1, 1, 0, 0, 0, 128);
							Screen->FastCombo(LAYER_BEAMOS2, LStartX-8, LStartY-8, CMB_BEAMOS_LASER_ENDPOINT, CS_BEAMOS_LASER_ENDPOINT, 128);
						}
						Screen->FastCombo(LAYER_BEAMOS1, Ghost_X, Ghost_Y+16, Combo+1, this->CSet, 128);
					}
					CheckBeamosLaser(ghost, LStartX, LStartY, LEndX, LEndY);
					Ghost_Waitframe(this, ghost, true, true);
				}
				//If it reaches full length
				if(!LaserEnded){
					while((!Screen->isSolid(LEndX, LEndY)&&!(LEndX<-16||LEndX>272||LEndY<-16||LEndY>192))||Distance(EyeX+8, EyeY+8, LEndX, LEndY)<BEAMOS_LASER_MINDIST){
						int LDist = Distance(LStartX, LStartY, LEndX, LEndY);
						LStartX += VectorX(BEAMOS_LASER_SPEED, Angle);
						LStartY += VectorY(BEAMOS_LASER_SPEED, Angle);
						LEndX += VectorX(BEAMOS_LASER_SPEED, Angle);
						LEndY += VectorY(BEAMOS_LASER_SPEED, Angle);
						if(Screen->isSolid(LEndX, LEndY))
							LaserEnded = true;
						if(EyeAngle<=0){
							Screen->Rectangle(LAYER_BEAMOS2, LStartX, LStartY-1, LStartX+LDist, LStartY+1, COLOR_BEAMOS_LASER2, 1, LStartX, LStartY, Angle, true, 128);
							Screen->Line(LAYER_BEAMOS2, LStartX, LStartY, LEndX, LEndY, COLOR_BEAMOS_LASER1, 1, 0, 0, 0, 128);
						}
						Beamos_Draw(this, ghost, Combo, EyeAngle);
						if(EyeAngle>0){
							Screen->Rectangle(LAYER_BEAMOS2, LStartX, LStartY-1, LStartX+LDist, LStartY+1, COLOR_BEAMOS_LASER2, 1, LStartX, LStartY, Angle, true, 128);
							Screen->Line(LAYER_BEAMOS2, LStartX, LStartY, LEndX, LEndY, COLOR_BEAMOS_LASER1, 1, 0, 0, 0, 128);
						}
						Screen->Rectangle(LAYER_BEAMOS2, LStartX, LStartY-1, LStartX+LDist, LStartY+1, COLOR_BEAMOS_LASER2, 1, LStartX, LStartY, Angle, true, 128);
						Screen->Line(LAYER_BEAMOS2, LStartX, LStartY, LEndX, LEndY, COLOR_BEAMOS_LASER1, 1, 0, 0, 0, 128);
						CheckBeamosLaser(ghost, LStartX, LStartY, LEndX, LEndY);
						Ghost_Waitframe(this, ghost, true, true);
					}
				}
				//Once the laser has hit a wall, make the ends meet again
				while(Distance(LStartX, LStartY, LEndX, LEndY)>BEAMOS_LASER_SPEED){
					int LDist = Distance(LStartX, LStartY, LEndX, LEndY);
					if(LaserLength>BEAMOS_LASER_LENGTH){
						LStartX += VectorX(BEAMOS_LASER_SPEED, Angle);
						LStartY += VectorY(BEAMOS_LASER_SPEED, Angle);
					}
					if(LaserLength<=BEAMOS_LASER_LENGTH)
						LaserLength += BEAMOS_LASER_SPEED;
					//Draw everything in order
					int EyeCombo = Combo+2+AngleDir8(EyeAngle);
					if(Link->HP>0){
						if(EyeAngle<=0){
							Screen->FastCombo(LAYER_BEAMOS2, EyeX, EyeY, EyeCombo, this->CSet, 128);
							Screen->Rectangle(LAYER_BEAMOS2, LStartX, LStartY-1, LStartX+LDist, LStartY+1, COLOR_BEAMOS_LASER2, 1, LStartX, LStartY, Angle, true, 128);
							Screen->Line(LAYER_BEAMOS2, LStartX, LStartY, LEndX, LEndY, COLOR_BEAMOS_LASER1, 1, 0, 0, 0, 128);
							if(LaserLength<=BEAMOS_LASER_LENGTH)
								Screen->FastCombo(LAYER_BEAMOS2, LStartX-8, LStartY-8, CMB_BEAMOS_LASER_ENDPOINT, CS_BEAMOS_LASER_ENDPOINT, 128);
							Screen->FastCombo(LAYER_BEAMOS2, LEndX-8, LEndY-8, CMB_BEAMOS_LASER_ENDPOINT, CS_BEAMOS_LASER_ENDPOINT, 128);
						}
						Screen->FastCombo(LAYER_BEAMOS2, Ghost_X, Ghost_Y, Combo, this->CSet, 128);
						if(EyeAngle>0){
							Screen->FastCombo(LAYER_BEAMOS2, EyeX, EyeY, EyeCombo, this->CSet, 128);
							Screen->Rectangle(LAYER_BEAMOS2, LStartX, LStartY-1, LStartX+LDist, LStartY+1, COLOR_BEAMOS_LASER2, 1, LStartX, LStartY, Angle, true, 128);
							Screen->Line(LAYER_BEAMOS2, LStartX, LStartY, LEndX, LEndY, COLOR_BEAMOS_LASER1, 1, 0, 0, 0, 128);
							if(LaserLength<=BEAMOS_LASER_LENGTH)
								Screen->FastCombo(LAYER_BEAMOS2, LStartX-8, LStartY-8, CMB_BEAMOS_LASER_ENDPOINT, CS_BEAMOS_LASER_ENDPOINT, 128);
							Screen->FastCombo(LAYER_BEAMOS2, LEndX-8, LEndY-8, CMB_BEAMOS_LASER_ENDPOINT, CS_BEAMOS_LASER_ENDPOINT, 128);
						}
						Screen->FastCombo(LAYER_BEAMOS1, Ghost_X, Ghost_Y+16, Combo+1, this->CSet, 128);
					}
					CheckBeamosLaser(ghost, LStartX, LStartY, LEndX, LEndY);
					Ghost_Waitframe(this, ghost, true, true);
				}
				for(int i=0; i<LaserCooldown; i++){
					EyeAngle = WrapDegrees(EyeAngle+IncrementAngle);
					Beamos_Draw(this, ghost, Combo, EyeAngle);
					Ghost_Waitframe(this, ghost, true, true);
				}
			}
			Beamos_Draw(this, ghost, Combo, EyeAngle);
			Ghost_Waitframe(this, ghost, true, true);
		}
	}
}

//These following two functions are taken from theRandomHeader.zh. If you're using that, you can delete them here.
// Function to see if a box has collided with a line
bool lineBoxCollision(int lineX1, int lineY1, int lineX2, int lineY2, int boxX1, int boxY1, int boxX2, int boxY2, int boxBorder)
{
	// Shrink down the box for the border
	boxX1 += boxBorder; boxY1 += boxBorder;
	boxX2 -= boxBorder; boxY2 -= boxBorder;
	
	// If the line isn't vertical
	if(lineX2!=lineX1)
	{
		
		float i0 = (boxX1 - lineX1)/(lineX2-lineX1);
		float i1 = (boxX2 - lineX1)/(lineX2-lineX1);
		
		float yA = lineY1 + i0*(lineY2-lineY1);
		float yB = lineY1 + i1*(lineY2-lineY1);
		
		
		if(Max(boxX1, boxX2) >= Min(lineX1, lineX2) && Min(boxX1, boxX2) <= Max(lineX1, lineX2) &&
			Max(boxY1, boxY2) >= Min(lineY1, lineY2) && Min(boxY1, boxY2) <= Max(lineY1, lineY2))
		{
			if(Min(boxY1, boxY2) > Max(yA, yB) || Max(boxY1, boxY2) < Min(yA, yB))
				return false;
			else
				return true;
		}
		else
			return false;
	}
	// If the line is vertical
	else if(lineX1 >= boxX1 && lineX1 <= boxX2)
	{
		// Basically we need to find the top and bottom y values of the line to check for intersection
		float lineYMin = lineY1;
		float lineYMax = lineY2;
		
		if(lineYMin > lineYMax)
		{
			lineYMin = lineY2;
			lineYMax = lineY1;
		}
		
		// If either point intersects
		if((boxY1 >= lineYMin && boxY1 <= lineYMax) || (boxY2 >= lineYMin && boxY2 <= lineYMax))
			return true;
	}
	
	return false;
} //! End of lineBoxCollision

// Function to get the difference between two angles
float angleDifference(float angle1, float angle2)
{
	// Get the difference between the two angles
	float dif = angle2 - angle1;
	
	// Compensate for the difference being outside of normal bounds
	if(dif >= PI)
		dif -= 2 * PI;
	else if(dif <= -1 * PI)
		dif += 2 * PI;
		
	return dif;
}


//global shield constants are here
const int SHIELD_ID = 8; //Constants should be in all-caps.
const int SHIELD_LOST_STRING = 452;
const int SHIELD_LOST_SOUND = 22;

//The Global Script is here
global script LostIsleTwo
{
	void run()
	{
		StartGhostZH();
		MooshPit_Init();
		CrystalSwitch_Init();
		bool hasShield;
		while(true)
		{
			if(hasShield && !Link->Item[SHIELD_ID])
			{
				lost_shield();
			}
			hasShield = Link->Item[SHIELD_ID];
                        UpdateGhostZH1();
			MooshPit_Update();
			CrystalSwitch_Update();
                        Waitdraw();
                        UpdateGhostZH2();
			Waitframe();
		}
	}
	
	void lost_shield()
	{
		if(SHIELD_LOST_STRING) Screen->Message(SHIELD_LOST_STRING);
		if(SHIELD_LOST_SOUND) Game->PlaySound(SHIELD_LOST_SOUND);
	}
}
// end of global script